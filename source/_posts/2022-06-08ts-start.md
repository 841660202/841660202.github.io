---
title: 1.Typescript起步
date: 2022-06-08 09:58:32
categories: typescript
tags: [typescript]
cover: https://img0.baidu.com/it/u=86492913,3057347241&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=208
---
## 说明

此文及后续的几篇是对[Typescript官方原文](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)的翻译，方便阅读

## Get Started

typescript 起步，分别针对 4 类不同的程序开发者进行引导， **对号入座**

- 新手程序猿，没有接触过任何开发语言
- JS 开发者
- Java/C#开发 [跳过]
- 函数式编程人员
- 5 分钟内了解 Typescript

## 新手程序猿

Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!
`祝贺您选择了 TypeScript 作为您的第一种语言，您已经做出了优秀的决策！`
You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.
`你大概已经听说过，TypeScript 是 JavaScript 的一个变体。TypeScript 和 JavaScript 的关系是在现代编程语言中非常独特的，所以学习更多关于这个关系的知识将帮助你了解 TypeScript 和 JavaScript 的区别。`

### What is JavaScript? A Brief History

`什么是 JavaScript？简单的历史`

JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.
`JavaScript 是一种简单的脚本语言，用于浏览器。在创建时，它预期会被用于嵌入在网页中的短片代码 — 写入超过十几行代码会有点不便。`
Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich applications of all kinds.
`Web 浏览器开发者对这个增加了 JS 使用的响应，优化了他们的执行引擎（动态编译）和扩展了他们可以做的事情（添加 APIs），这使得 Web 开发者使用它来做更多的事情。在现代网站上，您的浏览器通常运行着一些应用程序，其中包括千万行代码的应用程序。这是一个非常长的“网”的发展，从一个简单的静态页面开始，并进入一个丰富的应用程序的平台。`
More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use only JavaScript to program their entire stack!
`不仅如此，JS 变得越来越受欢迎，并且可以在浏览器之外使用，比如使用 node.js 来实现 JS 服务器。JS 的“运行在任何地方”性质使得它一个极受欢迎的选择。有许多开发者今天只使用 JavaScript 来编程他们的整个堆栈！`
To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own quirks — oddities and surprises, and JavaScript’s humble beginning makes it have many of these. Some examples:
`概括，我们有一种语言，被设计为快速使用，然后扩展到一个具有千万行代码的应用程序的工具。每种语言都有自己的特性，有的有点不同，有的有点惊人，而 JavaScript 的轻重感使得它有许多这些。有些例子：`

JavaScript’s equality operator (==) coerces its arguments, leading to unexpected behavior:
`JavaScript 的相等操作符（==）会强制转换它的参数，导致意外的行为：`

```js
if ("" == 0) {
  // It is! But why??
}
if (1 < x < 3) {
  // True for *any* value of x!
}
```

JavaScript also allows accessing properties which aren’t present:
`JavaScript 也允许访问不存在的属性：`

```js
const obj = { width: 10, height: 15 };
// Why is this NaN? Spelling is hard!
const area = obj.width * obj.heigth;
```

Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.
`大多数编程语言会抛出错误，当这些错误发生时，它们会抛出错误，而不是在编译时。当写小型程序时，这些惊人的惊喜是可接受的；当写大型应用程序时，这些惊喜是一个严重的问题。`

- TypeScript: A Static Type Checker

We said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as static checking. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static type checking.
`我们说过，某些语言不允许运行那些错误的程序。检测代码中的错误，而不运行它, 是静态检查。确定哪些是错误的，哪些是正确的，是基于值的类型的静态检查。`
TypeScript checks a program for errors before execution, and does so based on the kinds of values, it’s a static type checker. For example, the last example above has an error because of the type of obj. Here’s the error TypeScript found:
`TypeScript 检测程序前，并且基于值的类型，它是一个静态类型检查器。例如，上面的最后一个例子有一个错误，因为 obj 的类型是 NaN。这里 TypeScript 发现了错误：`

```js
const obj = { width: 10, height: 15 };
const area = obj.width * obj.heigth;
// Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?
```

### A Typed Superset of JavaScript

`一个类型定义的超集 JavaScript`

How does TypeScript relate to JavaScript, though?
`TypeScript 的类型定义是什么，和 JavaScript 的类型定义有什么关系？`

### Syntax 语法

TypeScript is a language that is a superset of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a syntax error because it’s missing a ):
`Typescript 是 JavaScript 的一个子集：JS 语言的语法是合法的 TS。语法是指我们写程序的方式。例如，这段代码有一个语法错误，因为没有一个）。`

```ts
let a = (4
')' expected.
```

TypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.
`TypeScript 不会认为任何 JavaScript 代码是错误的，因为它的语法。这意味着你可以把任何工作的 JavaScript 代码放在 TypeScript 文件中，而不用担心它的语法。`

### Types

类型

However, TypeScript is a typed superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about obj.heigth was not a syntax error: it is an error of using some kind of value (a type) in an incorrect way.

`然而，TypeScript 是一个类型的超集，意味着它添加了一些规则，如何使用不同类型的值。前面的错误，obj.heigth 是不是一个语法错误？它是一个错误的使用某种类型的值（一个类型）的方式。`

As another example, this is JavaScript code that you can run in your browser, and it will log a value:

`另一个例子，这是你可以在浏览器中运行的 JavaScript 代码，它会记录一个值：`

```ts
console.log(4 / []);
// The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
```

It’s possible you really did intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)

`之前一个数除以一个数组，可能仅仅是想看下会出现什么，尽管他是一个错误程序。Typescript 的类型检查器是设计的，让正确的程序通过，并且尽可能少的错误。(后面，我们会学习如何配置 TypeScript 检查你的代码。)`

If you move some code from a JavaScript file to a TypeScript file, you might see type errors depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.

`如果你从一个 JavaScript 文件移动到一个 TypeScript 文件，你可能会看到一些类型错误，取决于你的代码如何写。这些可能是代码的正确性，或者 TypeScript 过于保守。本指南中，我们会演示如何添加各种 TypeScript 语法，以便消除这些错误。`

### Runtime Behavior

`运行时行为`
TypeScript is also a programming language that preserves the runtime behavior of JavaScript. For example, dividing by zero in JavaScript produces Infinity instead of throwing a runtime exception. As a principle, TypeScript never changes the runtime behavior of JavaScript code.
TypeScript 也是一个编程语言，它保留 JavaScript 的运行时行为。例如，在 JavaScript 中除以零会产生无穷，而不是抛出一个运行时异常。作为一个原则，TypeScript 不会改变 JavaScript 代码的运行时行为。
This means that if you move code from JavaScript to TypeScript, it is guaranteed to run the same way, even if TypeScript thinks that the code has type errors.
`这意味着如果你从 JavaScript 移动到 TypeScript，它就保证会运行一样的，即使 TypeScript 认为代码有类型错误。`
Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.
`保持和 JavaScript 的运行时一致的行为是 TypeScript 的基础承诺，因为它意味着你可以很容易地从 JavaScript 到 TypeScript 过渡，而不用担心潜在的差异，可能会影响你的程序的正常运行。`

### Erased Types

`擦除类型`
Roughly speaking, once TypeScript’s compiler is done with checking your code, it erases the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.
`换句话说，一旦 TypeScript 编译器完成了检查你的代码，它会擦除类型，生成结果的“编译”代码。这意味着，一旦你的代码编译完成，结果的普通 JS 代码将没有类型信息。`
This also means that TypeScript never changes the behavior of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.
`这意味着，在编译时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。底线是，在运行时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。`
Finally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.
`最后，TypeScript 不提供任何额外的运行时库。你的程序将使用和 JavaScript 程序一样的标准库（或外部库），所以没有额外的 TypeScript-特定的框架来学习。`

### Learning JavaScript and TypeScript

`学习 JavaScript 和 TypeScript`
We frequently see the question “Should I learn JavaScript or TypeScript?“.
`我们经常会看到这个问题：“我应该学习 JavaScript 还是 TypeScript？”`
The answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.
`答案是，你不能学习 TypeScript，除非你学习 JavaScript！TypeScript 和 JavaScript 共享语法和运行时行为，所以你学习 JavaScript 的任何内容都是帮助你学习 TypeScript 的同时。`
There are many, many resources available for programmers to learn JavaScript; you should not ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged javascript than typescript, but all of the javascript questions also apply to TypeScript.
`有很多，很多资源可供程序员学习 JavaScript；如果你写 TypeScript，你不应该忽略这些资源。例如，有 20 倍的 StackOverflow 问题标记了 javascript，而 typescript 问题也适用于 javascript。`
If you find yourself searching for something like “how to sort a list in TypeScript”, remember: TypeScript is JavaScript’s runtime with a compile-time type checker. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.
`如果你发现自己在搜索“如何排序一个列表”，记住：TypeScript 是 JavaScript 的运行时，同时还有一个编译时类型检查器。你在 TypeScript 中排序一个列表的方式和在 JavaScript 中一样。如果你找到一个使用 TypeScript 的资源，那也是很好的，但不要限制自己在每天的问题中想要使用 TypeScript-特定的答案来实现运行时任务。`

### Next Steps

`下一步`
This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:
`这是一个简单的概述，从这里你可以：`
Learn some of the JavaScript fundamentals, we recommend either:
`学习 JavaScript 基本原理，我们建议：`
Microsoft’s JavaScript Resources or
JavaScript guide at the Mozilla Web Docs
Continue to TypeScript for JavaScript Programmers
`继续学习 TypeScript 为 JavaScript 程序员`
Read the full Handbook from start to finish (30m)
`阅读全部手册从头到尾（30 分钟）`大佬就是大佬 30 分钟能搞定，我估计要搞 3 天，手册这地方内容还是很多的
Explore the Playground examples
`探索 Playground 示例`

## JS 开发者

TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.
`TypeScript 与 JavaScript 的关系是不正常的。TypeScript 提供了 JavaScript 的所有功能，并且在这些功能的基础上添加了一层：TypeScript 的类型系统。`
For example, JavaScript provides language primitives like string and number, but it doesn’t check that you’ve consistently assigned these. TypeScript does.
`例如，JavaScript 提供了字符串和数字，但它不检查你是否按照一致的方式分配这些。TypeScript 也提供了。`
This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.
`这意味着你的已有的工作中的 JavaScript 代码也是 TypeScript 代码。TypeScript 的主要好处是它可以高亮你的代码中的意外行为，降低 bug 的可能性。`
This tutorial provides a brief overview of TypeScript, focusing on its type system.
`这个教程主要介绍 TypeScript 的类型系统。`

### Types by Inference

`类型推论`

TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.
`TypeScript 知道 JavaScript 语言，并且会为你生成类型。例如，创建一个变量并为它赋值，TypeScript 就会使用值作为它的类型。`

```ts
let helloWorld = "Hello World";

// let helloWorld: string
```

By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that helloWorld is a string in the above example.
`通过了解 JavaScript 工作方式，TypeScript 可以建立一个接受 JavaScript 代码，但有类型的类型系统。这个类型系统没有需要在你的代码中添加额外的字符来明确类型。这就是 TypeScript 知道 helloWorld 是一个字符串的原因。`

You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.
`你可能在 Visual Studio Code 中写了 JavaScript，并且有自动补全。Visual Studio Code 使用 TypeScript 作为后台来更加方便地工作。（原来如此）`

### Defining Types

`定义类型`
You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.
`你可以使用 JavaScript 的许多设计模式。_然而，有些设计模式使得类型无法被自动推断（例如，使用动态规划的模式_。为了解决这些情况，TypeScript 支持一个 JavaScript 的扩展，它提供了给你告诉 TypeScript 的类型应该是什么的地方。`
For example, to create an object with an inferred type which includes name: string and id: number, you can write:
`例如，创建一个具有推断类型的对象，它包含 name: string 和 id: number，你可以这样写：`

```ts
const user = {
  name: "Hayes",
  id: 0,
};
```

You can explicitly describe this object’s shape using an interface declaration:
`你可以使用接口声明来明确地描述这个对象的形状：`

```ts
interface User {
  name: string;
  id: number;
}
```

You can then declare that a JavaScript object conforms to the shape of your new interface by using syntax like : TypeName after a variable declaration:
`你可以使用类型名称来告诉 JavaScript 你的变量是属于哪个类型：`

```ts
const user: User = {
  name: "Hayes",
  id: 0,
};
```

If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:
`如果你提供的对象不符合你提供的接口，TypeScript 就会警告你：`

```ts
interface User {
  name: string;
  id: number;
}

const user: User = {
  username: "Hayes",
  // Type '{ username: string; id: number; }' is not assignable to type 'User'.
  // Object literal may only specify known properties, and 'username' does not exist in type 'User'.
  id: 0,
};
```

Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:
`因为 JavaScript 支持类和对象-面向对象编程，所以 TypeScript 也支持。你可以使用接口声明类：`

```ts
interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: User = new UserAccount("Murphy", 1);
```

You can use interfaces to annotate parameters and return values to functions:
`你可以使用接口来标注函数的参数和返回值：`

```ts
function getAdminUser(): User {
  //...
}

function deleteUser(user: User) {
  // ...
}
```

There is already a small set of primitive types available in JavaScript: boolean, bigint, null, number, string, symbol, and undefined, which you can use in an interface. TypeScript extends this list with a few more, such as any (allow anything), unknown (ensure someone using this type declares what the type is), never (it’s not possible that this type could happen), and void (a function which returns undefined or has no return value).
`已经有一些简单的原始类型可用于 JavaScript：boolean, bigint, null, number, string, symbol, 和 undefined，你可以在接口中使用它们。TypeScript 将这些类型扩展了一些，如 any（允许任何东西），unknown（确保使用者使用这个类型时声明了它的类型），never（不可能发生的类型），和 void（函数返回 undefined 或没有返回值）。`

You’ll see that there are two syntaxes for building types: Interfaces and Types. You should prefer interface. Use type when you need specific features.
`你会看到有两种编写类型的语法：接口和类型。当你需要特定的功能时，你应该使用接口。使用类型时，你需要特定的功能。`

### Composing Types

`组合类型`
With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.
`通过使用联合类型，或者通过使用泛型来组合复杂的类型。`

### Unions

`联合类型`
With a union, you can declare that a type could be one of many types. For example, you can describe a boolean type as being either true or false:
`通过使用联合类型，你可以声明一个类型是可能是 true 或 false 的类型。`

```ts
type MyBool = true | false;
```

Note: If you hover over MyBool above, you’ll see that it is classed as boolean. That’s a property of the Structural Type System. More on this below.
`请注意，如果你将鼠标移到 MyBool 上，你会看到它是一个 boolean 类型。这是结构类型系统的一个属性。更多内容在下面。`
A popular use-case for union types is to describe the set of string or number literals that a value is allowed to be:
`联合类型的一个常见用例是描述一个值可以是一个字符串或数字的集合：`

```ts
type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

Unions provide a way to handle different types too. For example, you may have a function that takes an array or a string:
`联合类型可以用来处理不同类型的参数。例如，你可以有一个函数可以接受一个数组或字符串类型的参数：`

```ts
function getLength(obj: string | string[]) {
  return obj.length;
}
```

To learn the type of a variable, use typeof:
`使用 typeof 来查看一个变量的类型：`

### Type Predicate

`类型断言`

```ts
string typeof s === "string"
number typeof n === "number"
boolean typeof b === "boolean"
undefined typeof undefined === "undefined"
function typeof f === "function"
array Array.isArray(a)
```

For example, you can make a function return different values depending on whether it is passed a string or an array:
`例如，你可以用来返回不同的值，根据传入的参数是字符串还是数组：`

```ts
function wrapInArray(obj: string | string[]) {
  if (typeof obj === "string") {
    return [obj];

    (parameter) obj: string
  }
  return obj;
}
```

### Generics

`泛型`

Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.
`泛型可以提供类型变量。例如，数组。数组没有泛型可以包含任何东西。数组有泛型可以描述数组中包含的值。`

```ts
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;
You can declare your own types that use generics:
```

`你可以声明自己的类型，使用泛型。`

```ts
interface Backpack<Type> {
  add: (obj: Type) => void;
  get: () => Type;
}

// This line is a shortcut to tell TypeScript there is a
// constant called `backpack`, and to not worry about where it came from.
declare const backpack: Backpack<string>;

// object is a string, because we declared it above as the variable part of Backpack.
const object = backpack.get();

// Since the backpack variable is a string, you can't pass a number to the add function.
backpack.add(23);
Argument of type 'number' is not assignable to parameter of type 'string'.
```

### Structural Type System

`结构类型系统`

One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.
`结构类型系统的一个核心原则是，类型检查只关注值的形状。这称为“鸭子类型”或“结构类型”。`
In a structural type system, if two objects have the same shape, they are considered to be of the same type.
`在结构类型系统中，如果两个对象具有相同的形状，则被视为相同的类型。`

```ts
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

// logs "12, 26"
const point = { x: 12, y: 26 };
logPoint(point);
```

The point variable is never declared to be a Point type. However, TypeScript compares the shape of point to the shape of Point in the type-check. They have the same shape, so the code passes.
`point 变量没有被声明为 Point 类型。但是，TypeScript 对比 point 和 Point 的形状，它们具有相同的形状，所以代码通过。`
The shape-matching only requires a subset of the object’s fields to match.
`结构类型系统只需要对象的一部分字段匹配。`

```ts
const point3 = { x: 12, y: 26, z: 89 };
logPoint(point3); // logs "12, 26"

const rect = { x: 33, y: 3, width: 30, height: 80 };
logPoint(rect); // logs "33, 3"

const color = { hex: "#187ABF" };
logPoint(color);
// Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.
// Type '{ hex: string; }' is missing the following properties from type 'Point': x, y
```

There is no difference between how classes and objects conform to shapes:
`类和对象都遵循结构类型系统。`

```ts
class VirtualPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const newVPoint = new VirtualPoint(13, 56);
logPoint(newVPoint); // logs "13, 56"
```

If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.
`如果对象或类有所有必要的属性，TypeScript将认为它们匹配，无论实现细节。`

### Next Steps

`下一步`
This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:
`从这里开始，你可以：`
Read the full Handbook from start to finish (30m)
`阅读完整手册（30分钟）`
Explore the Playground examples
`探索 Playground 示例`

## Java/C#开发

虽然 Java/C#也接触过，但这不是我本次的重点，之后会补上

## 函数式编程人员

TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.
`TypeScript 开始于一个尝试，将传统对象-对象类型的编程语言转换为 JavaScript，这样的编程人员可以将传统的对象-对象编程程序转换为 Web 端的程序。`
This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.
`这个介绍是为了工作 Haskell 或 ML 程序员而设计的，它描述了 TypeScript 的类型系统与 Haskell 的类型系统之间的不同。`
This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.
`这个介绍不会讲到对象-对象编程。实际上，在 TypeScript 中的对象-对象编程程序与其他流行语言的对象-对象编程程序相似。`

### Prerequisites

`先决条件`
In this introduction, I assume you know the following:
`在这个介绍中，我假设你知道了以下内容：`
How to program in JavaScript, the good parts.
`如何编写 JavaScript 程序，好的部分。`
Type syntax of a C-descended language.
`C-descended 语言的类型语法。`
If you need to learn the good parts of JavaScript, read JavaScript: The Good Parts. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. R4RS Scheme is a good example.
`如果你需要学习 JavaScript，请阅读 JavaScript：The Good Parts。如果你知道如何编写基于值词法的词法作用域语言，并且拥有大量可变性和不多的其他特性，你可以跳过这本书。R4RS Scheme 是一个好例子。`
The C++ Programming Language is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: x: string instead of string x.
`C++ 编程语言是一个好的地方学习 C-style 类型语法。`

### Concepts not in Haskell

`在 Haskell 中不存在的概念`

### Built-in types

`内置类型`
JavaScript defines 8 built-in types:
`JavaScript 定义了 8 个内置类型：` **这里是包装类型**
Type Explanation
`类型说明`
Number a double-precision IEEE 754 floating point.
`数字，双精度 IEEE 754 浮点数。`
String an immutable UTF-16 string.
`字符串，不可变的 UTF-16 字符串。`
BigInt integers in the arbitrary precision format.
`大整数，任意精度格式。`
Boolean true and false.
`布尔值，true 和 false。`
Symbol a unique value usually used as a key.
`符号，通常用作键。`
Null equivalent to the unit type.
`空，等同于单元类型。`
Undefined also equivalent to the unit type.
`未定义，也等同于单元类型。`
Object similar to records.
`对象，类似于记录。`
See the MDN page for more detail.
`参见 MDN 页面。`

TypeScript has corresponding primitive types for the built-in types:
`TypeScript 有对应的内置类型的原始类型：`
number
string
bigint
boolean
symbol
null
undefined
object

### Other important TypeScript types

`其他重要的 TypeScript 类型`
Type Explanation
`类型说明`
unknown the top type.
`未知类型，顶级类型。`
never the bottom type.
`永远不会是类型，底级类型。`
object literal eg { property: Type }
`对象字面量，例如 { property: 类型 }。`
void a subtype of undefined intended for use as a return type.
`void 类型，作为返回类型。`
T[] mutable arrays, also written Array<T>
`T[] 可变数组，也称为 Array<T>。`
[T, T] tuples, which are fixed-length but mutable
`[T, T] 元组，固定长度但可变。`
(t: T) => U functions
`(t: T) => U 函数。`
Notes:
`注意：`
Function syntax includes parameter names. This is pretty hard to get used to!
`函数语法包括参数名。这很难使用！`

```ts
let fst: (a: any, b: any) => any = (a, b) => a;
// or more precisely: 或者更准确地：
let fst: <T, U>(a: T, b: U) => T = (a, b) => a;
// Object literal type syntax closely mirrors object literal value syntax:
// 模式匹配字面量类型语法与对象字面量值语法类似。

let o: { n: number; xs: object[] } = { n: 1, xs: [] };
[T, T] is a subtype of T[].
// This is different than Haskell, where tuples are not related to lists.
// 此外，这是不同于 Haskell 的，元组不和列表相关。
```

### Boxed types

`包装类型`
JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type number and the boxed type Number. The boxed types are rarely needed, since their methods return primitives.
`JavaScript 有对应的包装类型，包含与这些类型相关的方法。`

```js
(1).toExponential();
// equivalent to
Number.prototype.toExponential.call(1);
```

Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.
`调用方法在数字字面量上需要在括号中，以帮助解析器。`

### Gradual typing

`渐进类型`
TypeScript uses the type any whenever it can’t tell what the type of an expression should be. Compared to Dynamic, calling any a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an any[] without marking the value in any way:
`TypeScript 使用 any 时，当它不能确定表达式的类型时。`
// with "noImplicitAny": false in tsconfig.json, anys: any[]
`在 tsconfig.json 中，加入 "noImplicitAny": false 可以禁用 anys: any[]。`

```ts
const anys = [];
anys.push(1);
anys.push("oh no");
anys.push({ anything: "goes" });
```

And you can use an expression of type any anywhere:
`你可以在任何地方使用 any 类型表达式。`

```ts
anys.map(anys[1]); // oh no, "oh no" is not a function
```

any is contagious, too — if you initialize a variable with an expression of type any, the variable has type any too.
`any 类型是传播的，` 如果初始化一个变量为 any 类型，变量的类型也是 any。

```ts
let sepsis = anys[0] + anys[1]; // this could mean anything
```

To get an error when TypeScript produces an any, use "noImplicitAny": true, or "strict": true in tsconfig.json.
`为了在 TypeScript 生成 any 时得到错误提示，使用 "noImplicitAny": true 或 "strict": true 在 tsconfig.json 中。`

### Structural typing

`结构类型`
Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:
`结构性类型是大多数函数编程程序员熟悉的概念，尽管 Haskell 和大多数 ML 不是结构性类型。`

```ts
// @strict: false
let o = { x: "hi", extra: 1 }; // ok
let o2: { x: string } = o; // ok
```

Here, the object literal { x: "hi", extra: 1 } has a matching literal type { x: string, extra: number }. That type is assignable to { x: string } since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of { x: string }.
`这里，对象字面量 { x: "hi", extra: 1 } 有一个匹配的字面量类型 { x: string, extra: number }。`
Named types just give a name to a type; for assignability purposes there’s no difference between the type alias One and the interface type Two below. They both have a property p: string. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)
`命名类型只是给一个类型命名；用于类型赋值的目的不同于接口下面的类型别名和类型参数，但是它们都有属性 p: string。 (类型别名和接口的递归定义和类型参数有所不同。)`

```ts
type One = { p: string };
interface Two {
  p: string;
}
class Three {
  p = "Hello";
}

let x: One = { p: "hi" };
let two: Two = x;
two = new Three();
```

### Unions

`联合类型`

In TypeScript, union types are untagged. In other words, they are not discriminated unions like data in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.
在 TypeScript 中，联合类型是无标签的。` 在其他语言中，联合类型是标签化的。`

```ts
function start(
  arg: string | string[] | (() => string) | { s: string }
): string {
  // this is super common in JavaScript
  if (typeof arg === "string") {
    return commonCase(arg);
  } else if (Array.isArray(arg)) {
    return arg.map(commonCase).join(",");
  } else if (typeof arg === "function") {
    return commonCase(arg());
  } else {
    return commonCase(arg.s);
  }

  function commonCase(s: string): string {
    // finally, just convert a string to another string
    return s;
  }
}
```

string, Array and Function have built-in type predicates, conveniently leaving the object type for the else branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.
`字符串、数组和函数有内置类型推断，` 可以在 else 分支中推断出对象类型。`The following types have built-in predicates:`下面的类型有内置推断：`Type Predicate`类型推断`

string typeof s === "string"
number typeof n === "number"
bigint typeof m === "bigint"
boolean typeof b === "boolean"
symbol typeof g === "symbol"
undefined typeof undefined === "undefined"
function typeof f === "function"
array Array.isArray(a)
object typeof o === "object"

Note that functions and arrays are objects at runtime, but have their own predicates.
`函数和数组在运行时是对象，` 但是有自己的推断。`

### Intersections

`交叉类型`

In addition to unions, TypeScript also has intersections:
`在 TypeScript 中，还有交叉类型：`

```ts
type Combined = { a: number } & { b: string };
type Conflicting = { a: number } & { a: string };
```

Combined has two properties, a and b, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so Conflicting.a: number & string.
`Combined 有两个属性，a 和 b， 如果写成一个对象字面量类型， 则 a 和 b 都是 number 和 string 类型。`

### Unit types

`单元类型`
Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string "foo" has the type "foo". Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:
`单元类型是原始类型的子类型， 它们包含一个原始值。`

```ts
declare function pad(s: string, n: number, direction: "left" | "right"): string;
pad("hi", 10, "left");
```

When needed, the compiler widens — converts to a supertype — the unit type to the primitive type, such as "foo" to string. This happens when using mutability, which can hamper some uses of mutable variables:
`当需要时，编译器会扩展， 将单元类型转换为原始类型， 例如 "foo" 转换为 string。`

```ts
let s = "right";
pad("hi", 10, s); // error: 'string' is not assignable to '"left" | "right"'
Argument of type 'string' is not assignable to parameter of type '"left" | "right"'.
```

Here’s how the error happens:
`这里有一个错误：`
"right": "right"

s: string because "right" widens to string on assignment to a mutable variable.
string is not assignable to "left" | "right"

You can work around this with a type annotation for s, but that in turn prevents assignments to s of variables that are not of type "left" | "right".
`你可以使用类型注解来解决这个问题， 但是这会导致 s 的赋值， 只能赋值给 "left" | "right" 类型的变量。`

```ts
let s: "left" | "right" = "right";
pad("hi", 10, s);
```

### Concepts similar to Haskell

`与 Haskell 类似的概念`

### Contextual typing

`上下文类型`

TypeScript has some obvious places where it can infer types, like variable declarations:
`TypeScript 有一些明显的地方， 可以推断类型， 如变量声明。`

```ts
let s = "I'm a string!";
```

But it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:
`TypeScript 也可以推断在某些地方没有声明类型的情况下， 如果你已经使用其他 C-语言语法：`

```ts
declare function map<T, U>(f: (t: T) => U, ts: T[]): U[];
let sns = map((n) => n.toString(), [1, 2, 3]);
```

Here, n: number in this example also, despite the fact that T and U have not been inferred before the call. In fact, after [1,2,3] has been used to infer T=number, the return type of n => n.toString() is used to infer U=string, causing sns to have the type string[].
`这里， n: number 在这个例子中也， 即使在调用之前没有推断 T 和 U 的类型。 在实际上， 在 [1,2,3] 被用来推断 T=number 的时候， n => n.toString() 的返回类型会被用来推断 U=string， 导致 sns 的类型为 string[]。`
Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare map with the array first:
`注意， 推断会工作在任何顺序， 但是 intellisense 只会从左到右， 因此 TypeScript 只会优先声明 map 函数， 先声明数组。`

```ts
declare function map<T, U>(ts: T[], f: (t: T) => U): U[];
```

Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as string or number. And it can infer return types from context:
`上下文类型也可以递归地通过对象字面量， 和单元类型， 如果没有声明类型， 则会被推断为 string 或 number。 并且可以从上下文中推断函数的返回类型。`

```ts
declare function run<T>(thunk: (t: T) => void): T;
let i: { inference: string } = run((o) => {
  o.inference = "INSERT STATE HERE";
});
```

The type of o is determined to be { inference: string } because
`这个 o 的类型是由 run 函数的参数类型决定的， 因为`
Declaration initializers are contextually typed by the declaration’s type: { inference: string }.
`声明初始值是由声明的类型决定的`
The return type of a call uses the contextual type for inferences, so the compiler infers that T={ inference: string }.
`调用的返回类型是由上下文类型决定的， 因此编译器会推断 T={ inference: string }。`
Arrow functions use the contextual type to type their parameters, so the compiler gives o: { inference: string }.
`箭头函数使用上下文类型来类型参数， 因此编译器会给 o: { inference: string }。`
And it does so while you are typing, so that after typing o., you get completions for the property inference, along with any other properties you’d have in a real program.
`而且这样， 在你输入 o. 的时候， 你会得到 inference 的属性的完整补全， 同时也会有其他实际程序中的属性。`
Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.
`这个功能可以让 TypeScript 的推断看起来像一个统一类型推断引擎， 但是它不是。`

### Type aliases

`类型别名`

Type aliases are mere aliases, just like type in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.
`类型别名是类型别名， 像 Haskell 中的类型。 编译器会尝试使用别名名称在源代码中使用， 但不一定成功。`

```ts
type Size = [number, number];
let x: Size = [101.1, 999.9];
```

The closest equivalent to newtype is a tagged intersection:
`最接近的等价是标记交集：`

```ts
type FString = string & { **compileTimeOnly: any };

```

An FString is just like a normal string, except that the compiler thinks it has a property named **compileTimeOnly that doesn’t actually exist. This means that FString can still be assigned to string, but not the other way round.
`FString 是一个普通字符串， 但是编译器认为它有一个名为 **compileTimeOnly 的属性， 这个属性并不存在。 这意味着 FString 仍然可以被赋值给 string， 但是不能被赋值给其他类型。`

### Discriminated Unions

`可识别联合`

The closest equivalent to data is a union of types with discriminant properties, normally called discriminated unions in TypeScript:
`最接近的等价是数据的一个联合类型， 常见的是 TypeScript 中的分层联合：`

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; x: number }
  | { kind: "triangle"; x: number; y: number };
```

Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading | is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:
`与 Haskell 不同， 标记， 或者说分层联合的标记， 在每个对象类型中都是一个属性。 每个变体都有一个相同的属性， 并且它的单元类型不同。 这仍然是一个联合类型； 前面的 | 是联合类型的可选部分。 你可以使用普通的 JavaScript 代码来区分联合成员：`

```ts
type Shape =
| { kind: "circle"; radius: number }
| { kind: "square"; x: number }
| { kind: "triangle"; x: number; y: number };

function area(s: Shape) {
  if (s.kind === "circle") {
    return Math.PI _ s.radius _ s.radius;
  } else if (s.kind === "square") {
    return s.x _ s.x;
  } else {
  r eturn (s.x _ s.y) / 2;
  }
}
```

Note that the return type of area is inferred to be number because TypeScript knows the function is total. If some variant is not covered, the return type of area will be number | undefined instead.
`注意， area 的返回类型被推断为 number， 因为 TypeScript 知道函数是完全的。 如果某个变体没有被覆盖， area 的返回类型将会是 number | undefined。`
Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:
`与 Haskell 不同， 共有属性在联合中显示， 你可以使用有效的方式来区分联合成员：`

```ts
function height(s: Shape) {
  if (s.kind === "circle") {
    return 2 \* s.radius;
  } else {
  // s.kind: "square" | "triangle"
    return s.x;
  }
}
```

### Type Parameters

`参数类型`
Like most C-descended languages, TypeScript requires declaration of type parameters:
`类似于大多数 C-descended 语言， TypeScript 需要声明类型参数：`

```ts
function liftArray<T>(t: T): Array<T> {
  return [t];
}
```

There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:
`没有要求， 但是类型参数是一个惯例， 单大写字母。 类型参数可以被限制为一个类型， 这个类型行为类似于类型约束：`

```ts
function firstish<T extends { length: number }>(t1: T, t2: T): T {
  return t1.length > t2.length ? t1 : t2;
}
```

TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.
`TypeScript 可以通过调用参数的类型推断出类型参数， 因此通常不需要指定类型参数。`
Because TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to propagate type information, such as constraining parameters to be the same type:
`TypeScript 是结构性的， 不需要类型参数， 因为它们不需要使一个函数多态。 类型参数只是用来传递类型信息， 如限制参数为相同类型：`

```ts
function length<T extends ArrayLike<unknown>>(t: T): number {}
function length(t: ArrayLike<unknown>): number {}
```

In the first length, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.
`在第一个 length， T 没有必要； 可以注意， 它只被引用一次， 因此它不会被用来限制返回值或其他参数的类型。`

### Higher-kinded types

`高阶类型`

TypeScript does not have higher kinded types, so the following is not legal:
`TypeScript 不支持高阶类型， 因此下面的不合法：`

```ts
function length<T extends ArrayLike<unknown>, U>(m: T<U>) {}
```

### Point-free programming

Point-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.
`点-free 编程 — 重量级的使用 curry 和函数组合 — 在 JavaScript 中可以， 但是可能会很多。 在 TypeScript 中， 类型推断对点-free 编程失败， 因此你会指定类型参数而不是值参数。 结果是这样的多， 因此比较适合避免点-free 编程。`

### Module system

`模块系统`

JavaScript’s modern module syntax is a bit like Haskell’s, except that any file with import or export is implicitly a module:
`JavaScript 的现代模块语法和 Haskell 类似， 只是任何带有 import 或 export 的文件都是隐式的模块：`

```ts
import { value, Type } from "npm-package";
import { other, Types } from "./local-package";
import \* as prefix from "../lib/third-package";

```

You can also import commonjs modules — modules written using node.js’ module system:
`你也可以导入 commonjs 模块 — 使用 node.js 的模块系统写的模块：`

```ts
import f = require("single-function-package");
```

You can export with an export list:
`你可以使用 export 列表导出：`

```ts
export { f };
function f() {
  return g();
}
function g() {} // g is not exported
```

Or by marking each export individually:
`或者通过单独标记每个导出：`

```ts
export function f { return g() }
function g() { }
```

The latter style is more common but both are allowed, even in the same file.
`后者更常见， 但是都可以， 即使在同一个文件中。`

### readonly and const

In JavaScript, mutability is the default, although it allows variable declarations with const to declare that the reference is immutable. The referent is still mutable:
`在 JavaScript 中， 可变性是默认的， 即使它允许使用 const 声明的变量声明引用是不可变的。 引用仍然可变：`

```ts
const a = [1, 2, 3];
a.push(102); // ):
a[0] = 101; // D:
```

TypeScript additionally has a readonly modifier for properties.
`TypeScript 还有一个 readonly 属性修饰符。`

```ts
interface Rx {
  readonly x: number;
}
let rx: Rx = { x: 1 };
rx.x = 12; // error
```

It also ships with a mapped type Readonly<T> that makes all properties readonly:
`它还有一个映射类型 Readonly<T>， 让所有属性都变成只读的：`

```ts
interface X {
  x: number;
}
let rx: Readonly<X> = { x: 1 };
rx.x = 12; // error
```

And it has a specific ReadonlyArray<T> type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:
`它还有一个特殊的 ReadonlyArray<T> 类型， 去除了侧影响的方法和防止写入数组索引， 同时还有这种类型的特殊语法：`

```ts
let a: ReadonlyArray<number> = [1, 2, 3];
let b: readonly number[] = [1, 2, 3];
a.push(102); // error
b[0] = 101; // error
```

You can also use a const-assertion, which operates on arrays and object literals:
`你也可以使用 const 断言， 它操作了数组和对象字面量：`

```ts
let a = [1, 2, 3] as const;
a.push(102); // error
a[0] = 101; // error
```

However, none of these options are the default, so they are not consistently used in TypeScript code.
`但是， 没有这些选项是默认的， 因此它们不是一致地使用在 TypeScript 代码中。`

### Next Steps

`下一步`

This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:
`此文档是日常代码中的语法和类型一个高级的概览， 从这里你应该：`
Read the full Handbook from start to finish (30m)
`阅读完整的手册（30分钟）`
Explore the Playground examples
`探索 Playground 示例`

## 5 分钟内了解 Typescript

跳过，这部分比较简单，看原文吧，之后重点放到手册里。