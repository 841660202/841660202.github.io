---
title: 前端基础-安全（摘抄）
date: 2022-07-15 14:32:30
categories: 前端基础
tags: [前端基础]
cover:
---

## 前端安全问题?

- `跨站脚本 (Cross-Site Scripting, XSS)`: ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS. 早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚ ⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / VBScript / CSS / Flash 等
- `跨站点请求伪造（Cross-Site Request Forgeries，CSRF）`: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤ 户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击
- `iframe 的滥⽤`: iframe 中的内容是由第三⽅来提供的，默认情况下他们不受我们的控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端⽤户体验
- `恶意第三⽅库`: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候我们都是在借助开发框架和各种类库进⾏ 快速开发,⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题,⽐如 event-stream 的恶意代码事件,2018 年 11 ⽉ 21 ⽇， 名为 FallingSnow 的⽤户在知名 JavaScript 应⽤库 event-stream 在 github Issuse 中发布了针对植⼊的恶意代码的疑 问，表示 event-stream 中存在⽤于窃取⽤户数字钱包的恶意代码

## XSS 分为哪⼏类?

根据攻击的来源，XSS 攻击可分为`存储型`、`反射型`和 `DOM型`三种。

### 存储型：

- 恶意代码存放的位置。 插⼊点：由谁取得恶意代码，并插⼊到⽹⻚上。 存储型 XSS 存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到⽬标⽹站的`数据库`中。
2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码`从数据库取出`，拼接在 HTML 中返回给浏览器。
3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。

**场景**

这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。

### 反射型

反射型 XSS 的攻击步骤：

1. 攻击者构`造出特殊的 URL`，其中包含恶意代码。
2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码`从URL中取出`，拼接在 HTML 中返回给浏览器。
3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。

**场景**

反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件⽐较苛刻（需要构造表单提交⻚⾯，并引导⽤户点击），所 以⾮常少⻅。

### DOM 型

XSS DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. ⽤户打开带有恶意代码的 URL。
3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。
4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：

DOM 型 XSS 攻击中，`取出和执⾏恶意代码由浏览器端完成`，属于前端 JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。

## 如何预防 XSS?

XSS 攻击有两⼤要素：

1. 攻击者提交恶意代码。
2. 浏览器执⾏恶意代码。

针对第⼀个要素：我们是否能够在⽤户输⼊的过程，过滤掉⽤户输⼊的恶意代码呢？

### 输⼊过滤

- 防⽌ HTML 中出现注⼊
- 防⽌ JavaScript 执⾏时，执⾏恶意代码

### 存储型和反射型 XSS

如何产生？

存储型和反射型 XSS 都是在服务端取出恶意代码后，插⼊到响应 HTML ⾥的，攻击者刻意编写的“数据”被内嵌到“代 码”中，被浏览器所执⾏。

预防这两种漏洞，有两种常⻅做法：

- 改成纯前端渲染，把代码和数据分隔开
- 对 HTML 做充分转义。

### DOM 型 XSS

DOM 型 XSS 攻击，实际上就是⽹站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执⾏了。

- 在使⽤ `.innerHTML` 、 `.outerHTML` 、 `document.write()` 时要特别⼩⼼，不要把不可信的数据作为 HTML 插到⻚⾯上，⽽应尽量使⽤ `.textContent` 、 `.setAttribute()` 等。
  <br/>
  <br/>
- 如果⽤ Vue/React 技术栈，并且不使⽤ `v-html` / `dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML` 、 `outerHTML` 的 XSS 隐患。

  <br/>
  <br/>

- DOM 中的内联事件监听器，如 location 、 onclick 、 onerror 、 onload 、 onmouseover 等，
  <br/>
  <br/>
- `<a>` 标签的 href 属 性，
  <br/>
  <br/>
- JavaScript 的 `eval()` 、 `setTimeout()` 、 `setInterval()` 等，都能`把字符串作为代码运⾏`。

如果不可信的数据拼接 到字符串中传递给这些 API，很容易产⽣安全隐患，请务必避免。

```html
<!-- 内联事件监听器中包含恶意代码 -->
![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,)

<!-- 链接内包含恶意代码 -->
<a href="UNTRUSTED">1</a>

<script>
  // setTimeout()/setInterval() 中调⽤恶意代码

  setTimeout("UNTRUSTED");
  setInterval("UNTRUSTED");

  // location 调⽤恶意代码

  location.href = "UNTRUSTED";

  // eval() 中调⽤恶意代码
  eval("UNTRUSTED");
</script>
```

### 其他 XSS 防范措施

虽然在渲染⻚⾯和执⾏ JavaScript 时，通过谨慎的转义可以防⽌ XSS 的发⽣，但完全依靠开发的谨慎仍然是不够的。

以下介绍⼀些通⽤的⽅案，可以降低 XSS 带来的⻛险和后果。

- `Content Security Policy` 严格的 CSP 在 XSS 的防范中可以起到以下的作⽤： 禁⽌加载外域代码，防⽌复杂的攻击逻辑 禁⽌外域提交，⽹站被攻击后，⽤户的数据不会泄露到外域

- `禁⽌内联脚本执⾏`（规则较严格，⽬前发现 GitHub 使⽤） 禁⽌未授权的脚本执⾏（新特性，Google Map 移动版在使⽤）

- `合理使⽤上报`可以及时发现 XSS，利于尽快修复问题 输⼊内容⻓度控制 对于不受信任的输⼊，都应该限定⼀个合理的⻓度。虽然⽆法完全防⽌ XSS 发⽣，但可以增加 XSS 攻击的难度。

- 其他安全措施` HTTP-only Cookie`: 禁⽌ JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注⼊后也⽆法窃取此 Cookie。 验证码：防⽌脚本冒充⽤户提交危险操作。

## CSRF 是什么?

`CSRF（Cross-site request forgery）跨站请求伪造`：攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹ 站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证，绕过后台的⽤户验证，达到冒充⽤户对被攻击的⽹站 执⾏某项操作的⽬的。 ⼀个典型的 CSRF 攻击有着如下的流程：

- 受害者登录 a.com ，并保留了登录凭证（Cookie）
- 攻击者引诱受害者访问了 b.com b.com 向 a.com 发送了⼀个请求： a.com/act=xx
- 浏览器会默认携带 a.com 的 Cookie a.com 接收到请求后，对请求进⾏验证，并确认是受害者的凭证，误以为是受害者⾃⼰发送的请求
- a.com 以受害者的名义执⾏了 act=xx
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执⾏了⾃⼰定义的操作

## CSRF 的攻击类型?

- GET 类型的 CSRF
- POST 类型的 CSRF
- 链接类型的 CSRF

## 如何预防 CSRF?

CSRF 通常从第三⽅⽹站发起，被攻击的⽹站⽆法防⽌攻击发⽣，只能通过增强⾃⼰⽹站针对 CSRF 的防护能⼒来提升安全性。
CSRF 的两个特点：

- CSRF（通常）发⽣在第三⽅域名
- CSRF 攻击者不能获取到 Cookie 等信息，只是使⽤。

针对这两点，我们可以专⻔制定防护策略，如下：

- 阻⽌不明外域的访问
  1. `同源检测`
  2. `Samesite Cookie`
- 提交时要求附加本域才能获取的信息
  1. CSRF Token
  2. 双重 Cookie 验证

因此我们可以针对性得进⾏预防

### 同源检测

既然 CSRF ⼤多来⾃第三⽅⽹站，那么我们就直接禁⽌外域（或者不受信任的域名）对我们发起请求:

- 使⽤ Origin Header 确定来源域名: 在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段,如果 Origin 存在，那么直接使⽤ Origin 中的字段确认来源域名就可以
- 使⽤ Referer Header 确定来源域名: 根据 HTTP 协议，在 HTTP 头中有⼀个字段叫 Referer，记录了该 HTTP 请求的来 源地址

### CSRF Token

CSRF 的另⼀个特征是，攻击者⽆法直接窃取到⽤户的信息（Cookie，Header，⽹站内容等），仅仅是冒⽤ Cookie 中的 信息。

⽽ CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了⽤户⾃⼰的请求。那么我们可以要求所有的 ⽤户请求都携带⼀个 CSRF 攻击者⽆法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求 和攻击的请求区分开，也可以防范 CSRF 的攻击:

CSRF Token 的防护策略分为三个步骤：

- 将 CSRF Token 输出到⻚⾯中
- ⻚⾯提交的请求携带这个 Token
- 服务器验证 Token 是否正确

### 双重 Cookie 验证

在会话中存储 CSRF Token ⽐较繁琐，⽽且不能在通⽤的拦截上统⼀处理所有的接⼝ 那么另⼀种防御措施是使⽤双重提交 Cookie。利⽤ CSRF 攻击不能获取到⽤户 Cookie 的特点，我们可以要求 Ajax 和表单 请求携带⼀个 Cookie 中的值

双重 Cookie 采⽤以下流程：

- 在⽤户访问⽹站⻚⾯时，向请求域名注⼊⼀个 Cookie，内容为随机字符串（例如 csrfcookie=v8g9e4ksfhw ）。
- 在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例 POST https://www.a.com/comment? csrfcookie=v8g9e4ksfhw ）。
- 后端接⼝验证 Cookie 中的字段与 URL 参数中的字段是否⼀致，不⼀致则拒绝。

### Samesite Cookie 属性

Google 起草了⼀份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它⽤来标明这个 Cookie 是 个“同站 Cookie”，同站 Cookie 只能作为第⼀⽅ Cookie，不能作为第三⽅ Cookie，Samesite 有两个属性值:

- Samesite=Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三⽅ Cookie
- Samesite=Lax: 这种称为宽松模式，⽐ Strict 放宽了点限制,假如这个请求是这种请求且同时是个 GET 请求，则这个 Cookie 可以作为第三⽅ Cookie

## ⽹络劫持

⽹络劫持⼀般分为两种:

- `DNS 劫持`: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持) DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器
- `302 跳转的⽅式`: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起 302 跳转的回复，引导⽤户获取内容
- `HTTP 劫持`: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于 http 明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)

## 如何应对⽹络劫持?

- DNS 劫持由于涉嫌违法,已经被监管起来,现在很少会有 DNS 劫持,⽽ http 劫持依然⾮常盛⾏.
- 最有效的办法就是全站 HTTPS,将 HTTP 加密,这使得运营商⽆法获取明⽂,就⽆法劫持你的响应内容.

## 中间⼈攻击

中间⼈ (Man-in-the-middle attack, MITM) 是指`攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话`, 但事实上整个会话都被攻击者完全控制. 在中间⼈攻击中, 攻击者可以拦截通讯双⽅的通话并插⼊新的内容.

⼀般的过程如下:

- 客户端发送请求到服务端，请求被中间⼈截获服务器向客户端发送公钥中间⼈截获公钥，保留在⾃⼰⼿上。
- 然后⾃⼰⽣成⼀个`【伪造的】公钥`，发给客户端
- 客户端收到伪造的公钥后，⽣成加密 hash 值发给服务器
- 中间⼈获得加密 hash 值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密 hash 值，发给服务器
- 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端

## DDoS 攻击

> `DDos`全名`Distributed Denial of Service`，翻译成中文就是`分布式拒绝服务`。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。

攻击方式很多，比如`UDP Flood`、`SYN Flood`、`DNS Query Flood`等等。

**下面是 SYN Flood 进行 DDoS 攻击的实现原理**

SYN Flood 是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。

一次正常的建立 TCP 连接，需要三次握手：客户端发送 SYN 报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。

SYN Flood 就是用户向服务器发送报文后突然死机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认报文（第三次握手无法完成），这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。

`一个用户出现异常导致服务器的一个线程等待一会儿并不是大问题`，但恶意攻击者大量模拟这种情况，服务器端为了维护数以万计的半连接而消耗非常多的资源，结果往往是无暇理睬客户的正常请求，甚至崩溃。从正常客户的角度看来，网站失去了响应，无法访问。

### 高防服务器

还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。

高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~

### 黑名单

面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。

### DDoS 清洗

DDos 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。

DDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。

### CDN 加速

CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。

在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。

## 参考链接

<a href="https://blog.csdn.net/weixin_38405253/article/details/114297755" target="_blank" >DDoS 攻击原理</a>
