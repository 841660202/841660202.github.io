---
title: Vue Pinia
date: 2022-06-10 17:21:00
categories:
tags: []
cover: http://t-blog-images.aijs.top/img/20220610172420.webp
---

## Pinia 特点

**💡 Intuitive**
`直观的`
Stores are as familiar as components. API designed to let you write well organized stores.
`存储和组件是一样的。API设计了让你写好组织的存储。`

**🔑 Type Safe**
`类型安全的`
Types are inferred, which means stores provide you with autocompletion even in JavaScript!
`类型可推测，这意味着存储提供了你在JavaScript中自动完成的功能！`

**⚙️ Devtools support**
`开发工具支持`
Pinia hooks into Vue devtools to give you an enhanced development experience in both Vue 2 and Vue 3.
`Pinia钩子进入Vue开发工具，让你在Vue 2和Vue 3中获得强化开发经验。`

**🔌 Extensible**
`可扩展的`
React to store changes to extend Pinia with transactions, local storage synchronization, etc.
`通过事务、本地存储同步等来响应存储更改以扩展Pinia。`

**🏗 Modular by design**
`设计模块化`
Build multiple stores and let your bundler code split them automatically.
`构建多个存储，让你的bundler代码分开它们自动。`

**📦 Extremely light**
`非常轻量的`
Pinia weighs around 1kb, you will forget it's even there!
`Pinia约1kb，你会忘记它在那里！`

## Introduction

`介绍`

<VueSchoolLink
  href="https://vueschool.io/lessons/introduction-to-pinia"
  title="Get started with Pinia"
/>

Pinia [started](https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e) as an experiment to redesign what a Store for Vue could look like with the [Composition API](https://github.com/vuejs/composition-api) around November 2019. Since then, the initial principles are still the same, but Pinia works for both Vue 2 and Vue 3 **and doesn't require you to use the composition API**. The API is the same for both except for _installation_ and _SSR_, and these docs are targeted to Vue 3 **with notes about Vue 2** whenever necessary so it can be read by Vue 2 and Vue 3 users!

_译：Pinia 从 2019 年 11 月左右开始尝试重新设计 Vue store 的合成 API。从那时起，最初的原则仍然是一样的，但 Pinia 同时适用于 Vue 2 和 Vue 3，不需要您使用合成 API。除了安装和 SSR 之外，这两个 API 都是相同的，这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的说明，以便 Vue 2 和 Vue 3 用户可以阅读！_

**Why should I use Pinia?**

`为什么我应该使用Pinia？`

Pinia is a store library for Vue, it allows you to share a state across components/pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple `export const state = reactive({})`. This is true for single page applications but **exposes your application to [security vulnerabilities](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)** if it is server side rendered. But even in small single page applications, you get a lot from using Pinia:

_译：Pinia 是一个 Vue 的存储库，它允许你在组件/页面之间共享状态。如果你熟悉合成 API，你可能会认为你可以通过简单的`export const state = reactive({})`共享全局状态。这是对于单页应用的真实情况，但_ **如果它是服务器端渲染，它会暴露您的应用程序到[安全漏洞](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)**。_但即使是小的单页应用，使用 Pinia 也很多：_

- Devtools support _开发工具支持_
  - A timeline to track actions, mutations _追踪行动、突变的时间表_
  - Stores appear in components where they are used _存储出现在使用它们的组件中_
  - Time travel and easier debugging _时间旅行和更容易调试_
- Hot module replacement _快速更新_
  - Modify your stores without reloading your page _在不重新加载页面的情况下修改你的存储_
  - Keep any existing state while developing _在开发时保持任何现有状态_
- Plugins: extend Pinia features with plugins _功能扩展：使用插件扩展 Pinia 功能_
- Proper TypeScript support or **autocompletion** for JS users \*对于 JS 用户的正确的 TypeScript 支持或**自动完成\***
- Server Side Rendering Support _完美的服务器端渲染支持_

**Basic example**

`基本示例`
This is what using pinia looks like in terms of API (make sure to check the [Getting Started](./getting-started.md) for complete instructions). You start by creating a store:
_译：这是为什么使用 pinia 看起来像 API（请检查[开始](./getting-started.md)以获取完整的指令）。你首先创建一个存储：_

```js
// stores/counter.js
import { defineStore } from "pinia";

export const useCounterStore = defineStore("counter", {
  state: () => {
    return { count: 0 };
  },
  // could also be defined as
  // state: () => ({ count: 0 })
  actions: {
    increment() {
      this.count++;
    },
  },
});
```

And then you _use_ it in a component:
_译：然后你在组件中`使用`它：_

```js
import { useCounterStore } from "@/stores/counter";

export default {
  setup() {
    const counter = useCounterStore();

    counter.count++;
    // with autocompletion ✨
    counter.$patch({ count: counter.count + 1 });
    // or using an action instead
    counter.increment();
  },
};
```

You can even use a function (similar to a component `setup()`) to define a Store for more advanced use cases:
_译：你也可以使用函数（与组件`setup()`相似）来定义一个存储以更高级的使用情况：_

```js
export const useCounterStore = defineStore("counter", () => {
  const count = ref(0);
  function increment() {
    count.value++;
  }

  return { count, increment };
});
```

If you are still not into `setup()` and Composition API, don't worry, Pinia also support a similar set of [_map helpers_ like Vuex](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper). You define stores the same way but then use `mapStores()`, `mapState()`, or `mapActions()`:
_译：如果你还不是`setup()`和 Composition API 的熟悉，不用担心，Pinia 也支持[Vuex 的*map helpers*（如 Vuex）](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper)。你定义存储的方式相同，然后使用`mapStores()`, `mapState()`,或`mapActions()`：_

```js
const useCounterStore = defineStore("counter", {
  state: () => ({ count: 0 }),
  getters: {
    double: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++;
    },
  },
});

const useUserStore = defineStore("user", {
  // ...
});

export default {
  computed: {
    // other computed properties
    // ...
    // gives access to this.counterStore and this.userStore
    ...mapStores(useCounterStore, useUserStore),
    // gives read access to this.count and this.double
    ...mapState(useCounterStore, ["count", "double"]),
  },
  methods: {
    // gives access to this.increment()
    ...mapActions(useCounterStore, ["increment"]),
  },
};
```

You will find more information about each _map helper_ in the core concepts.
_译：你将找到更多关于每个*map helper*的信息。_

**Why _Pinia_**

_为什么叫 Pinia_

Pinia (pronounced `/piːnjʌ/`, like "peenya" in English) is the closest word to _piña_ (_pineapple_ in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It's also a delicious tropical fruit indigenous to South America.

_Pinia 发音 `/piːnjʌ/`，类似于英语中的“柠檬”，它是一个有效的包名。一个柠檬是实际上是一组单个花朵结合在一起，以创建多个水果。与存储相似，每一个都是单独出生的，但是他们都是最终连接在一起的。它也是一个在南美洲的美食。_

**A more realistic example**

_译：更真实的例子_
Here is a more complete example of the API you will be using with Pinia **with types even in JavaScript**. For some people, this might be enough to get started without reading further but we still recommend checking the rest of the documentation or even skipping this example and coming back once you have read about all of the _Core Concepts_.
_译：这是一个更完整的例子，你将使用 Pinia**类型在 JavaScript**。对于一些人，这可能是足够开始而不需要阅读更多，但我们仍然建议检查其余的文档或跳过这个例子，然后回来一次你已经阅读了所有的**核心概念**。_

```js
import { defineStore } from "pinia";

export const todos = defineStore("todos", {
  state: () => ({
    /** @type {{ text: string, id: number, isFinished: boolean }[]} */
    todos: [],
    /** @type {'all' | 'finished' | 'unfinished'} */
    filter: "all",
    // type will be automatically inferred to number
    // 类型将自动推断为number
    nextId: 0,
  }),
  getters: {
    finishedTodos(state) {
      // autocompletion! ✨
      // 自动完成
      return state.todos.filter((todo) => todo.isFinished);
    },
    unfinishedTodos(state) {
      return state.todos.filter((todo) => !todo.isFinished);
    },
    /**
     * @returns {{ text: string, id: number, isFinished: boolean }[]}
     */
    filteredTodos(state) {
      if (this.filter === "finished") {
        // call other getters with autocompletion ✨
        // 调用其他getters自动完成
        return this.finishedTodos;
      } else if (this.filter === "unfinished") {
        return this.unfinishedTodos;
      }
      return this.todos;
    },
  },
  actions: {
    // any amount of arguments, return a promise or not
    // 任意数量的参数，返回一个promise或不
    addTodo(text) {
      // you can directly mutate the state
      // 你可以直接修改状态
      this.todos.push({ text, id: this.nextId++, isFinished: false });
    },
  },
});
```

**Comparison with Vuex**

_译：与 Vuex 比较_

Pinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.
_译：Pinia 开始了一个探索 Vuex 的下一个迭代，并且将大量的想法从 Vuex 5 的核心团队讨论中提取。最终，我们认为 Pinia 已经实现了大部分我们想要的 Vuex 5，并且决定改变它的推荐。_
Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.
_译：与 Vuex 比较，Pinia 提供了更简单的 API，提供了组合 API 的 API，并且在使用 TypeScript 时有实体类型支持。_

**RFCs**

_译：RFCs_

> RFCs 涵盖了 Vue 的最基本的四个部分，截至目前为止，已经有 38 个 PR 提交（26 个仍在讨论中），这些提议中既有 Vue 作者自己的提议，也有开发者的提议。
>
> - Vue core
> - Vue Router
> - Vuex
> - Vue CLI

Initially Pinia didn't go through any RFC. I tested out ideas based on my experience developing applications, reading other people's code, working for clients who use Pinia, and answering questions on Discord.
This allowed me to provide a solution that works and is adapted to a variety of cases and application sizes. I used to publish often and made the library evolve while keeping its core API the same.
_译：初始 Pinia 没有通过任何 RFC。我测试了基于我的经验开发应用程序，阅读其他人的代码，为使用 Pinia 的客户工作，并在 Discord 上回答问题。这让我提供了一个解决方案，它工作并适合各种情况和应用程序大小。我经常发布，并在保持核心 API 相同的情况下，使库发展。_
Now that Pinia has become the default state management solution, it is subject to the same RFC process as other core libraries in the Vue ecosystem and its API has entered a stable state.
_译：现在，Pinia 已经成为 Vue 的核心状态管理解决方案，它与 Vue 社区中其他核心库的 RFC 进行了相同的处理，并且它的 API 已经进入了一个稳定状态。_

**Comparison with Vuex 3.x/4.x**

_译：与 Vuex 3.x/4.x 比较_

> Vuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3
> Vuex 3.x 是 Vuex 2 的 Vuex，而 Vuex 4.x 是 Vue 3 的 Vuex
> Pinia API is very different from Vuex ≤4, namely:
> _译：Pinia API 与 Vuex 3.x/4.x 比较，主要区别是：_

- _mutations_ no longer exist. They were very often perceived as **_extremely_ verbose**. They initially brought devtools integration but that is no longer an issue.
  `- mutations 不再存在。它们初始上抛了开发工具集成，但这不再是问题。`
- No need to create custom complex wrappers to support TypeScript, everything is typed and the API is designed in a way to leverage TS type inference as much as possible.
  `- 没有需要创建自定义复杂的包装来支持TypeScript，所有的都是类型化的，API设计了一个让你最大限度地利用TS类型推断的方式。`
- No more magic strings to inject, import the functions, call them, enjoy autocompletion!
  `- 没有更多的魔法字符串注入，导入函数，调用它们，享受自动完成！`
- No need to dynamically add stores, they are all dynamic by default and you won't even notice. Note you can still manually use a store to register it whenever you want but because it is automatic you don't need to worry about it.
  `- 没有需要动态添加存储，它们都是默认的动态的，你也不会发现。请注意，你仍然可以手动使用存储来注册它，但是因为它是自动的，你不需要担心它。`
- No more nested structuring of _modules_. You can still nest stores implicitly by importing and _using_ a store inside another but Pinia offers a flat structuring by design while still enabling ways of cross composition among stores. **You can even have circular dependencies of stores**.
  `- 没有更多的嵌套结构的_模块_。你仍然可以嵌套存储通过导入并使用存储在另一个存储中，但Pinia提供了一个平面的结构，而且还允许在存储之间跨越组合。**你还可以有圆形依赖的存储**。`
- No _namespaced modules_. Given the flat architecture of stores, "namespacing" stores is inherent to how they are defined and you could say all stores are namespaced.
  `- 没有_命名空间模块_。给定存储的平面建构，“命名空间”存储是因为它们定义的方式而具有的，你可以说所有的存储都是命名空间。`
  For more detailed instructions on how to convert an existing Vuex ≤4 project to use Pinia, see the [Migration from Vuex Guide](./cookbook/migration-vuex.md).
  _译：为了更加详细的指导如何将现有的 Vuex ≤4 项目转换为使用 Pinia，请参阅[Migration from Vuex Guide](./cookbook/migration-vuex.md)。_

## [起步](https://pinia.vuejs.org/getting-started.html#installation)

### Installation

Install `pinia` with your favorite package manager:
_译：使用你喜欢的包管理器安装 `pinia` ：_

```bash
yarn add pinia
# or with npm
npm install pinia
```

:::tip
If your app is using Vue 2, you also need to install the composition api: `@vue/composition-api`. If you are using Nuxt, you should follow [these instructions](https://pinia.vuejs.org/ssr/nuxt.html).
_译：如果你的应用使用 Vue 2，你还需要安装组合 api：`@vue/composition-api`。如果你使用 Nuxt，你应该遵循[这些指导](https://pinia.vuejs.org/ssr/nuxt.html)。_
:::

If you are using the Vue CLI, you can instead give this [**unofficial plugin**](https://github.com/wobsoriano/vue-cli-plugin-pinia) a try.
\_译：如果你使用 Vue CLI，你可以试试这个 [**非官方插件**](

Create a pinia (the root store) and pass it to the app:
_译：创建一个 pinia （根存储）并将其传递给应用：_

```js
import { createPinia } from "pinia";

app.use(createPinia());
```

If you are using Vue 2, you also need to install a plugin and inject the created `pinia` at the root of the app:
_译：如果你使用 Vue 2，你还需要安装一个插件并将创建的 `pinia` 注入到应用的根中：_

```js
import { createPinia, PiniaVuePlugin } from "pinia";

Vue.use(PiniaVuePlugin);
const pinia = createPinia();

new Vue({
  el: "#app",
  // other options...
  // ...
  // note the same `pinia` instance can be used across multiple Vue apps on the same page
  // 注意，同一个 `pinia` 实例可以在同一个页面上的多个 Vue 应用中使用
  pinia,
});
```

This will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn't expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).
_译：这也会添加 devtools 支持。在 Vue 3 中，某些功能（例如时间旅行和编辑）仍然不支持，因为 vue-devtools 不暴露了必要的 API，但是 devtools 有更多的功能，开发者体验整体更优。在 Vue 2 中，Pinia 使用现有的 Vuex 接口（因此不能与它一起使用）。_

### What is a Store?

A Store (like Pinia) is an entity holding state and business logic that isn't bound to your Component tree. In other words, **it hosts global state**. It's a bit like a component that is always there and that everybody can read off and write to. It has **three concepts**, the [state](./core-concepts/state.md), [getters](./core-concepts/getters.md) and [actions](./core-concepts/actions.md) and it's safe to assume these concepts are the equivalent of `data`, `computed` and `methods` in components.
_译：一个存储（像 Pinia）是一个持有状态和业务逻辑的实体，它不是绑定到你的组件树上的。也就是说，**它持有全局状态**。它是一个总是存在的组件，每个人都可以读取并写入。它有 **三个概念**，[state](./core-concepts/state.md)，[getters](./core-concepts/getters.md) 和 [actions](./core-concepts/actions.md)，并且我们假设这三个概念是组件的 `data`，`computed` 和 `methods` 的等价。_

### When should I use a Store

A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.
_译：一个存储应该包含可以在整个应用程序中访问的数据。这包括在多个地方使用的数据，例如在导航栏中显示的用户信息，以及需要在页面中保留的数据，例如一个复杂的多步骤表单。_
On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.
_译：另一方面，你应该避免在存储中包含在组件中存储的本地数据，例如页面中的一个元素的可见性。_
Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.
_译：不是所有应用都需要访问全局状态，但如果你的应用需要一个，Pinia 将使你的生活更加方便。_

## 核心概念

### Store

**Defining a Store**

<VueSchoolLink
  href="https://vueschool.io/lessons/define-your-first-pinia-store"
  title="Learn how to define and use stores in Pinia"
/>

Before diving into core concepts, we need to know that a store is defined using `defineStore()` and that it requires a **unique** name, passed as the first argument:
_译：在深入核心概念之前，我们需要知道一个存储由 `defineStore()` 定义并且需要一个 **唯一的** 名称作为第一个参数：_

```js
import { defineStore } from "pinia";

// useStore could be anything like useUser, useCart
// the first argument is a unique id of the store across your application
export const useStore = defineStore("main", {
  // other options...
});
```

This _name_, also referred as _id_, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function _use..._ is a convention across composables to make its usage idiomatic.
_译：这个名称，也称为 _id_，是必需的并且用于连接存储到 devtools。命名返回的函数 _use..._ 是一个组合使用的惯例，使用它的用法简单易懂。_
**Using the store**

We are _defining_ a store because the store won't be created until `useStore()` is called inside of `setup()`:
_译：我们正在定义一个存储，因为只有在`setup（）`内部调用`useStore（）`才能创建该存储_

```js
import { useStore } from "@/stores/counter";

export default {
  setup() {
    const store = useStore();

    return {
      // you can return the whole store instance to use it in the template
      // 你可以在模板中返回整个存储实例来使用它
      store,
    };
  },
};
```

You can define as many stores as you want and **you should define each store in a different file** to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).
_译 ：你可以定义多个存储，你应该在不同的文件中定义每个存储来获得 pinia 的最大效用（例如自动允许你的 bundle 分割和 TypeScript 推断）。_
If you are not using `setup` components yet, [you can still use Pinia with _map helpers_](https://pinia.vuejs.org/cookbook/options-api.html).
_译：如果你还没有使用 `setup` 组件，你仍然可以使用 Pinia 与 [map 助手]（https://pinia.vuejs.org/cookbook/options-api.html）。_
Once the store is instantiated, you can access any property defined in `state`, `getters`, and `actions` directly on the store. We will see these in detail in the next pages but autocompletion will help you.
_译：一旦存储被实例化，你可以直接在存储上访问 `state`，`getters` 和 `actions` 中定义的属性。我们将在下一页中详细讲解，但是自动补全将帮助你。_
Note that `store` is an object wrapped with `reactive`, meaning there is no need to write `.value` after getters but, like `props` in `setup`, **we cannot destructure it**:
_译：请注意，存储是一个 `reactive` 包装的对象，因此不需要写 `.value` 后面的 getters，但是，像 `setup` 中的 `props`，我们不能解构它_

```js
export default defineComponent({
  setup() {
    const store = useStore();
    // ❌ This won't work because it breaks reactivity it's the same as destructuring from `props`
    // 这不会工作，因为它会破坏可观察性，它是相同的为 `props` 构造的
    const { name, doubleCount } = store;

    name; // "eduardo"
    doubleCount; // 2

    return {
      // will always be "eduardo"
      // 将始终是 "eduardo"
      name,
      // will always be 2
      // 将始终是 2
      doubleCount,
      // this one will be reactive
      // 这个将是可观察的
      doubleValue: computed(() => store.doubleCount),
    };
  },
});
```

In order to extract properties from the store while keeping its reactivity, you need to use `storeToRefs()`. It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:
_译：为了从存储中提取属性而保持其可观察性，你需要使用 `storeToRefs()`。它会创建每个可观察属性的 ref。这对于只使用存储中的状态但不调用任何行为时非常有用。请注意，你可以直接从存储中解构 actions，因为它们都是绑定到存储本身的。_

```js
import { storeToRefs } from "pinia";

export default defineComponent({
  setup() {
    const store = useStore();
    // `name` and `doubleCount` are reactive refs
    // This will also create refs for properties added by plugins
    // but skip any action or non reactive (non ref/reactive) property
    const { name, doubleCount } = storeToRefs(store);
    // the increment action can be just extracted
    const { increment } = store;

    return {
      name,
      doubleCount,
      increment,
    };
  },
});
```

### State

<VueSchoolLink
  href="https://vueschool.io/lessons/access-state-from-a-pinia-store"
  title="Learn all about state in Pinia"
/>

The state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.
_大多数时候，state是你store的中心。人们通常从定义代表其应用程序的状态开始。在Pinia中，状态定义为返回初始状态的函数。这允许Pinia在服务器端和客户端都工作。_
```js
import { defineStore } from "pinia";

const useStore = defineStore("storeId", {
  // arrow function recommended for full type inference
  state: () => {
    return {
      // all these properties will have their type inferred automatically
      counter: 0,
      name: "Eduardo",
      isAdmin: true,
    };
  },
});
```

:::tip
If you are using Vue 2, the data you create in `state` follows the same rules as the `data` in a Vue instance, ie the state object must be plain and you need to call `Vue.set()` when **adding new** properties to it. **See also: [Vue#data](https://v2.vuejs.org/v2/api/#data)**.
_如果你使用 Vue 2，在 `state` 中创建的数据遵循 Vue 实例中的 `data` 的规则，即 state 对象必须是纯粹的，并且需要在 **添加新的** 属性时调用 `Vue.set()`。请参见 [Vue#data](https://v2.vuejs.org/v2/api/#data)。_
:::

**Accessing the `state`**

By default, you can directly read and write to the state by accessing it through the `store` instance:
_默认情况下，你可以直接读取和写入状态，通过访问 `store` 实例来访问它：_
```js
const store = useStore();

store.counter++;
```

**Resetting the state**

You can _reset_ the state to its initial value by calling the `$reset()` method on the store:
_你可以通过调用 `$reset()` 方法来重置状态：_
```js
const store = useStore();

store.$reset();
```

**Usage with the Options API**

<VueSchoolLink
  href="https://vueschool.io/lessons/access-pinia-state-in-the-options-api"
  title="Access Pinia State via the Options API"
/>

For the following examples, you can assume the following store was created:
_为了下面的例子，你可以假设以下的存储已创建：_
```js
// Example File Path:
// ./src/stores/counterStore.js

import { defineStore } from "pinia";

const useCounterStore = defineStore("counterStore", {
  state: () => ({
    counter: 0,
  }),
});
```

If you are not using the Composition API, and you are using `computed`, `methods`, ..., you can use the `mapState()` helper to map state properties as readonly computed properties:
_如果你不使用 Composition API，并且使用 `computed`、`methods` 等，你可以使用 `mapState()` 帮助器来映射状态属性为只读的计算属性：_
```js
import { mapState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component
    // same as reading from store.counter
    ...mapState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapState(useCounterStore, {
      myOwnName: 'counter',
      // you can also write a function that gets access to the store
      double: store => store.counter * 2,
      // it can have access to `this` but it won't be typed correctly...
      magicValue(store) {
        return store.someGetter + this.counter + this.double
      },
    }),
  },
}
```

**Modifiable state**

If you want to be able to write to these state properties (e.g. if you have a form), you can use `mapWritableState()` instead. Note you cannot pass a function like with `mapState()`:
_如果你想要写入这些状态属性（例如，如果你有一个表单），你可以使用 `mapWritableState()`。注意，你不能传递一个函数类似于 `mapState()`：_
```js
import { mapWritableState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component and allows setting it
    // this.counter++
    // same as reading from store.counter
    ...mapWritableState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapWritableState(useCounterStore, {
      myOwnName: 'counter',
    }),
  },
}
```

:::tip
You don't need `mapWritableState()` for collections like arrays unless you are replacing the whole array with `cartItems = []`, `mapState()` still allows you to call methods on your collections.
_注意，你不需要 `mapWritableState()` 为集合类型（例如数组），除非你想要替换整个数组为 `cartItems = []`，`mapState()` 仍然允许你调用集合的方法。_
:::

**Mutating the state**

<!-- TODO: disable this with `strictMode` -->

Apart from directly mutating the store with `store.counter++`, you can also call the `$patch` method. It allows you to apply multiple changes at the same time with a partial `state` object:
_除了直接通过 `store.counter++` 来修改存储，你也可以调用 `$patch()` 方法。它允许你同时使用一个部分 `state` 对象来应用多个变更：_
```js
store.$patch({
  counter: store.counter + 1,
  name: "Abalam",
});
```

However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the `$patch` method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:
_但是，一些变更非常难或者昂贵地应用，因为它们需要创建一个新的集合。因此，`$patch` 方法也接受一个函数来组织这种难以应用的变更：_
```js
cartStore.$patch((state) => {
  state.items.push({ name: "shoes", quantity: 1 });
  state.hasChanged = true;
});
```

<!-- TODO: disable this with `strictMode`, `{ noDirectPatch: true }` -->

The main difference here is that `$patch()` allows you to group multiple changes into one single entry in the devtools. Note **both, direct changes to `state` and `$patch()` appear in the devtools** and can be time travelled (not yet in Vue 3).
_主要的区别是，`$patch()` 允许你将多个变更组成一个单独的条目在 devtools 中。注意 **两者都会在 devtools 中出现，并且可以被时间轴追踪（尚未在 Vue 3 中）。_
**Replacing the `state`**

You can replace the whole state of a store by setting its `$state` property to a new object:
_你可以通过设置存储的 `$state` 属性来替换它的状态：_
```js
store.$state = { counter: 666, name: "Paimon" };
```

You can also replace the whole state of your application by changing the `state` of the `pinia` instance. This is used during [SSR for hydration](../ssr/#state-hydration).
_你也可以通过更改 `pinia` 实例的 `state` 来替换整个应用的状态。这用于 [SSR for hydration](../ssr/#state-hydration)。_
```js
pinia.state.value = {};
```

**Subscribing to the state**

You can watch the state and its changes through the `$subscribe()` method of a store, similar to Vuex's [subscribe method](https://vuex.vuejs.org/api/#subscribe). The advantage of using `$subscribe()` over a regular `watch()` is that _subscriptions_ will trigger only once after _patches_ (e.g. when using the function version from above).
_你可以通过存储的 `$subscribe()` 方法来订阅状态，与 Vuex 的 [subscribe 方法](https://vuex.vuejs.org/api/#subscribe) 类似。使用 `$subscribe()` 方法来订阅状态，优势在于它会在变更后只触发一次订阅（例如，使用上面的函数版本）。_
```js
cartStore.$subscribe((mutation, state) => {
  // import { MutationType } from 'pinia'
  mutation.type; // 'direct' | 'patch object' | 'patch function'
  // same as cartStore.$id
  mutation.storeId; // 'cart'
  // only available with mutation.type === 'patch object'
  mutation.payload; // patch object passed to cartStore.$patch()

  // persist the whole state to the local storage whenever it changes
  localStorage.setItem("cart", JSON.stringify(state));
});
```

By default, _state subscriptions_ are bound to the component where they are added (if the store is inside a component's `setup()`). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass `{ detached: true }` as the second argument to _detach_ the _state subscription_ from the current component:
_默认情况下，_状态订阅_会绑定到添加它的组件（如果存储在组件的 `setup()` 中）。意味着，它会在组件卸载后自动删除。如果你想要在组件卸载后保持它们，可以将 `{ detached: true }` 作为第二个参数传递给 _detach_ _状态订阅_ 从当前组件：_
```js
export default {
  setup() {
    const someStore = useSomeStore();

    // this subscription will be kept after the component is unmounted
    someStore.$subscribe(callback, { detached: true });

    // ...
  },
};
```

:::tip
You can watch the whole state on the `pinia` instance:
你可以监听整个pinia实例的状态，这个状态是一个对象，包含了所有的store的状态。

```js
watch(
  pinia.state,
  (state) => {
    // persist the whole state to the local storage whenever it changes
    localStorage.setItem("piniaState", JSON.stringify(state));
  },
  { deep: true }
);
```

:::


## Getters

<VueSchoolLink
  href="https://vueschool.io/lessons/getters-in-pinia"
  title="Learn all about getters in Pinia"
/>

Getters are exactly the equivalent of [computed values](https://v3.vuejs.org/guide/reactivity-computed-watchers.html#computed-values) for the state of a Store. They can be defined with the `getters` property in `defineStore()`. They receive the `state` as the first parameter **to encourage** the usage of arrow function:
_获取器是状态的计算值。它们可以通过 `defineStore()` 中的 `getters` 属性来定义。它们会接收 `state`（使用箭头函数） 作为第一个参数，：_
```js
export const useStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  getters: {
    doubleCount: (state) => state.counter * 2,
  },
})
```

Most of the time, getters will only rely on the state, however, they might need to use other getters. Because of this, we can get access to the _whole store instance_ through `this` when defining a regular function **but it is necessary to define the type of the return type (in TypeScript)**. This is due to a known limitation in TypeScript and **doesn't affect getters defined with an arrow function nor getters not using `this`**:
_大多数情况下，获取器只依赖于状态，但它们可能需要使用其他获取器。因此，我们可以通过 `this` 访问到整个存储实例（但是需要在TypeScript中定义返回类型），这是因为已知的限制，不影响使用箭头函数或不使用`this`的获取器：_
```ts
export const useStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  getters: {
    // automatically infers the return type as a number
    // 自动推断返回类型为数字
    doubleCount(state) {
      return state.counter * 2
    },
    // the return type **must** be explicitly set
    //  返回类型 **必须** 被显式设置
    doublePlusOne(): number {
      // autocompletion and typings for the whole store ✨
      // 对于整个store自动完成和类型推断 ✨
      return this.doubleCount + 1
    },
  },
})
```

Then you can access the getter directly on the store instance:
_然后你可以直接在存储实例上访问获取器：_

```ts
<template>
  <p>Double count is {{ store.doubleCount }}</p>
</template>

<script>
export default {
  setup() {
    const store = useStore()

    return { store }
  },
}
</script>
```

## Accessing other getters

As with computed properties, you can combine multiple getters. Access any other getter via `this`. Even if you are not using TypeScript, you can hint your IDE for types with the [JSDoc](https://jsdoc.app/tags-returns.html):
_如同计算属性，你可以将多个获取器组合在一起。通过 `this` 访问其他获取器。即使你不使用TypeScript，你也可以通过[JSDoc](https://jsdoc.app/tags-returns.html)提示你的IDE类型：_
```js
export const useStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  getters: {
    // type is automatically inferred because we are not using `this`
    // 类型自动推断，因为我们不使用`this`
    doubleCount: (state) => state.counter * 2,
    // here we need to add the type ourselves (using JSDoc in JS). We can also
    // use this to document the getter
    // 在这里我们需要自己添加类型（使用JSDoc在JS）。我们也可以用这个来描述获取器
    /**
     * Returns the counter value times two plus one.
     *
     * @returns {number}
     */
    doubleCountPlusOne() {
      // autocompletion ✨
      return this.doubleCount + 1
    },
  },
})
```

## Passing arguments to getters

_Getters_ are just _computed_ properties behind the scenes, so it's not possible to pass any parameters to them. However, you can return a function from the _getter_ to accept any arguments:
_获取器是组件的计算属性，因此不能传递任何参数。然而，你可以从获取器返回一个函数，接受任何参数：_
```js
export const useStore = defineStore('main', {
  getters: {
    getUserById: (state) => {
      return (userId) => state.users.find((user) => user.id === userId)
    },
  },
})
```

and use in component:
_在组件中使用：_

```ts
<script>
export default {
  setup() {
    const store = useStore()

    return { getUserById: store.getUserById }
  },
}
</script>

<template>
  <p>User 2: {{ getUserById(2) }}</p>
</template>
```

Note that when doing this, **getters are not cached anymore**, they are simply functions that you invoke. You can however cache some results inside of the getter itself, which is uncommon but should prove more performant:
_注意，当这做的时候，**获取器不再缓存了**，它们是一个函数，你可以在获取器内部缓存一些结果，这是一种比较常见的情况，但是应该更有效率：_
```js
export const useStore = defineStore('main', {
  getters: {
    getActiveUserById(state) {
      const activeUsers = state.users.filter((user) => user.active)
      return (userId) => activeUsers.find((user) => user.id === userId)
    },
  },
})
```

## Accessing other stores getters

To use another store getters, you can directly _use it_ inside of the _getter_:
_要使用另一个存储获取器，可以直接在获取器中_使用它_：_
```js
import { useOtherStore } from './other-store'

export const useStore = defineStore('main', {
  state: () => ({
    // ...
  }),
  getters: {
    otherGetter(state) {
      const otherStore = useOtherStore()
      return state.localData + otherStore.data
    },
  },
})
```

## Usage with `setup()`

You can directly access any getter as a property of the store (exactly like state properties):
_你可以直接在存储中作为属性访问任何获取器（精准地如同状态属性）：_
```js
export default {
  setup() {
    const store = useStore()

    store.counter = 3
    store.doubleCount // 6
  },
}
```

## Usage with the Options API

<VueSchoolLink
  href="https://vueschool.io/lessons/access-pinia-getters-in-the-options-api"
  title="Access Pinia Getters via the Options API"
/>

For the following examples, you can assume the following store was created:
_对于下面的例子，你可以假设以下存储已创建：_
```js
// Example File Path:
// ./src/stores/counterStore.js

import { defineStore } from 'pinia',

const useCounterStore = defineStore('counterStore', {
  state: () => ({
    counter: 0
  }),
  getters: {
    doubleCounter(state) {
      return state.counter * 2
    }
  }
})
```

### With `setup()`

While Composition API is not for everyone, the `setup()` hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!
_而不是所有人都需要使用组合API，`setup()`钩子可以让Pinia更容易地在Options API中使用。没有额外的映射助手函数需要！_

## 这是一个优点
```js
import { useCounterStore } from '../stores/counterStore'

export default {
  setup() {
    const counterStore = useCounterStore()

    return { counterStore }
  },
  computed: {
    quadrupleCounter() {
      return this.counterStore.doubleCounter * 2
    },
  },
}
```

### Without `setup()`

You can use the same `mapState()` function used in the [previous section of state](./state.md#options-api) to map to getters:
_你可以使用在[上一节状态](./state.md#options-api)中使用的`mapState()`函数来映射到获取器：_
```js
import { mapState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.doubleCounter inside the component
    // same as reading from store.doubleCounter
    ...mapState(useCounterStore, ['doubleCount'])
    // same as above but registers it as this.myOwnName
    ...mapState(useCounterStore, {
      myOwnName: 'doubleCounter',
      // you can also write a function that gets access to the store
      double: store => store.doubleCount,
    }),
  },
}
```

# Actions

<VueSchoolLink
  href="https://vueschool.io/lessons/synchronous-and-asynchronous-actions-in-pinia"
  title="Learn all about actions in Pinia"
/>

Actions are the equivalent of [methods](https://v3.vuejs.org/guide/data-methods.html#methods) in components. They can be defined with the `actions` property in `defineStore()` and **they are perfect to define business logic**:
_在`defineStore()`中定义的`actions`属性是组件的方法，它们可以用来定义业务逻辑：_
```js
export const useStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  actions: {
    increment() {
      this.counter++
    },
    randomizeCounter() {
      this.counter = Math.round(100 * Math.random())
    },
  },
})
```

Like [getters](./getters.md), actions get access to the _whole store instance_ through `this` with **full typing (and autocompletion ✨) support**. **Unlike getters, `actions` can be asynchronous**, you can `await` inside of actions any API call or even other actions! Here is an example using [Mande](https://github.com/posva/mande). Note the library you use doesn't matter as long as you get a `Promise`, you could even use the native `fetch` function (browser only):
_像[获取器](./getters.md)一样，actions可以通过`this`访问整个存储实例，**它们可以是异步的**，你可以在actions中使用`await`任何API调用或者可以使用其他actions！这里是一个使用[Mande](_
```js
import { mande } from 'mande'

const api = mande('/api/users')

export const useUsers = defineStore('users', {
  state: () => ({
    userData: null,
    // ...
  }),

  actions: {
    async registerUser(login, password) {
      try {
        this.userData = await api.post({ login, password })
        showTooltip(`Welcome back ${this.userData.name}!`)
      } catch (error) {
        showTooltip(error)
        // let the form component display the error
        return error
      }
    },
  },
})
```

You are also completely free to set whatever arguments you want and return anything. When calling actions, everything will be automatically inferred!
_你可以设置任何参数和返回任何东西，当调用actions时，所有的东西都会自动推断！_
Actions are invoked like methods:
_actions像方法被调用：_
```js
export default defineComponent({
  setup() {
    const main = useMainStore()
    // call the action as a method of the store
    main.randomizeCounter()

    return {}
  },
})
```

## Accessing other stores actions

To use another store, you can directly _use it_ inside of the _action_:
_要使用另一个存储，你可以直接在_action_中使用它：_

## 这比react好用，可以嵌套

```js
import { useAuthStore } from './auth-store'

export const useSettingsStore = defineStore('settings', {
  state: () => ({
    preferences: null,
    // ...
  }),
  actions: {
    async fetchUserPreferences() {
      const auth = useAuthStore()
      if (auth.isAuthenticated) {
        this.preferences = await fetchPreferences()
      } else {
        throw new Error('User must be authenticated')
      }
    },
  },
})
```

## Usage with `setup()`

You can directly call any action as a method of the store:
_你可以直接调用任何action作为store的方法：_

```js
export default {
  setup() {
    const store = useStore()

    store.randomizeCounter()
  },
}
```

## Usage with the Options API

<VueSchoolLink
  href="https://vueschool.io/lessons/access-pinia-actions-in-the-options-api"
  title="Access Pinia Getters via the Options API"
/>

For the following examples, you can assume the following store was created:
_对于下面的例子，你可以假设以下的存储已经创建：_
```js
// Example File Path:
// ./src/stores/counterStore.js

import { defineStore } from 'pinia',

const useCounterStore = defineStore('counterStore', {
  state: () => ({
    counter: 0
  }),
  actions: {
    increment() {
      this.counter++
    }
  }
})
```

### With `setup()`

While Composition API is not for everyone, the `setup()` hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!
_Composition API不是所有人都能用，但是`setup()`钩子可以让Pinia更加简单地使用在Options API中，不需要额外的映射功能！_
```js
import { useCounterStore } from '../stores/counterStore'

export default {
  setup() {
    const counterStore = useCounterStore()

    return { counterStore }
  },
  methods: {
    incrementAndPrint() {
      this.counterStore.increment()
      console.log('New Count:', this.counterStore.count)
    },
  },
}
```

### Without `setup()`

If you would prefer not to use Composition API at all, you can use the `mapActions()` helper to map actions properties as methods in your component:
_如果你想不使用Composition API，你可以使用`mapActions()`助手来将actions属性映射为组件的方法：_
```js
import { mapActions } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  methods: {
    // gives access to this.increment() inside the component
    // same as calling from store.increment()
    ...mapActions(useCounterStore, ['increment'])
    // same as above but registers it as this.myOwnName()
    ...mapActions(useCounterStore, { myOwnName: 'doubleCounter' }),
  },
}
```

## Subscribing to actions

It is possible to observe actions and their outcome with `store.$onAction()`. The callback passed to it is executed before the action itself. `after` handle promises and allows you to execute a function after the action resolves. In a similar way, `onError` allows you execute a function if the action throws or rejects. These are useful for tracking errors at runtime, similar to [this tip in the Vue docs](https://v3.vuejs.org/guide/tooling/deployment.html#tracking-runtime-errors).
_可以使用`store.$onAction()`来观察actions和它们的结果。传入的回调会在action自身之前执行。`after`处理promises，允许你在action解决之后执行一个函数。同样，`onError`允许你在action抛出或者reject之后执行一个函数。这些是用于跟踪运行时错误的好方法，类似于[这个提示在Vue文档](https://v3.vuejs.org/guide/tooling/deployment.html#tracking-runtime-errors)。_
Here is an example that logs before running actions and after they resolve/reject.
_这是一个例子，它会在执行actions之前和之后解决/reject。_
```js
const unsubscribe = someStore.$onAction(
  ({
    name, // name of the action
    store, // store instance, same as `someStore`
    args, // array of parameters passed to the action
    after, // hook after the action returns or resolves
    onError, // hook if the action throws or rejects
  }) => {
    // a shared variable for this specific action call
    // 共享变量，这个特定的action调用
    const startTime = Date.now()
    // this will trigger before an action on `store` is executed
    // 这将触发在`store`上执行action之前
    console.log(`Start "${name}" with params [${args.join(', ')}].`)

    // this will trigger if the action succeeds and after it has fully run.
    // 这将触发如果action成功并且完成运行。
    // it waits for any returned promised
    //  它等待任何返回的promised
    after((result) => {
      console.log(
        `Finished "${name}" after ${
          Date.now() - startTime
        }ms.\nResult: ${result}.`
      )
    })

    // this will trigger if the action throws or returns a promise that rejects
    //  这将触发如果action抛出或者返回一个promise，reject
    onError((error) => {
      console.warn(
        `Failed "${name}" after ${Date.now() - startTime}ms.\nError: ${error}.`
      )
    })
  }
)

// manually remove the listener
// 手动移除监听器
unsubscribe()
```

By default, _action subscriptions_ are bound to the component where they are added (if the store is inside a component's `setup()`). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass `true` as the second argument to _detach_ the _action subscription_ from the current component:
_默认情况下，action订阅是绑定到添加它们的组件（如果store在组件的setup中）。意思是，它们会在组件被卸载后自动移除。如果你想要保持它们在组件被卸载后，将第二个参数传递给_detach_action订阅_从当前组件：_
```js
export default {
  setup() {
    const someStore = useSomeStore()

    // this subscription will be kept after the component is unmounted
    someStore.$onAction(callback, true)

    // ...
  },
}
```


# Plugins

Pinia stores can be fully extended thanks to a low level API. Here is a list of things you can do:
_Pinia stores可以完全扩展，通过一个低级API。这是一个列表，你可以做的事情：_
- Add `new properties` to stores _给stores添加新的属性_
- Add `new options` when defining stores _在定义stores时添加新的选项_
- Add `new methods` to stores _给stores添加新的方法_
- Wrap `existing methods` _包装现有的方法_
- Change or even cancel `actions` _改变或取消actions_
- Implement side effects like [Local Storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) _实现副作用效果，例如localStorage_
- Apply **only** to specific stores _只应用到特定的stores_

Plugins are added to the pinia instance with `pinia.use()`. The simplest example is adding a static property to all stores by returning an object:
_插件是添加到pinia实例的`pinia.use()`。最简单的例子是添加一个静态属性到所有stores，通过返回一个对象：_
```js
import { createPinia } from 'pinia'

// add a property named `secret` to every store that is created after this plugin is installed
// this could be in a different file
function SecretPiniaPlugin() {
  return { secret: 'the cake is a lie' }
}

const pinia = createPinia()
// give the plugin to pinia
pinia.use(SecretPiniaPlugin)

// in another file
const store = useStore()
store.secret // 'the cake is a lie'
```

This is useful to add global objects like the router, modal, or toast managers.
_这是有用的，例如router、modal或toast管理器_
## Introduction

A Pinia plugin is a function that optionally returns properties to be added to a store. It takes one optional argument, a _context_:
_一个Pinia插件是一个可选的返回属性的函数。它只接受一个可选的参数，一个_context_：_
```js
export function myPiniaPlugin(context) {
  context.pinia // the pinia created with `createPinia()` 
  context.app // the current app created with `createApp()` (Vue 3 only)
  context.store // the store the plugin is augmenting
  context.options // the options object defining the store passed to `defineStore()`
  // ...
}
```

This function is then passed to `pinia` with `pinia.use()`:
_这个函数是通过`pinia.use()`传递给`pinia`：_
```js
pinia.use(myPiniaPlugin)
```

Plugins are only applied to stores **created after `pinia` is passed to the app**, otherwise they won't be applied.
_插件只应用到stores **在`pinia`被传递给app后创建**，否则它们不会应用_
## Augmenting a Store

You can add properties to every store by simply returning an object of them in a plugin:
_你可以通过返回一个对象来给每个store添加属性_
```js
pinia.use(() => ({ hello: 'world' }))
```

You can also set the property directly on the `store` but **if possible use the return version so they can be automatically tracked by devtools**:
_你也可以直接给store设置属性，但是**如果可能，请使用返回版本，以便它们可以被自动追踪**_
```js
pinia.use(({ store }) => {
  store.hello = 'world'
})
```

Any property _returned_ by a plugin will be automatically tracked by devtools so in order to make `hello` visible in devtools, make sure to add it to `store._customProperties` **in dev mode only** if you want to debug it in devtools:
_任何插件返回的属性都会被自动追踪被devtools追踪，所以要让hello可见在devtools，请在dev模式下，如果你想要调试它在devtools，请在store._customProperties中添加它：_
```js
// from the example above
pinia.use(({ store }) => {
  store.hello = 'world'
  // make sure your bundler handle this. webpack and vite should do it by default
  // 确定你的bundler处理这个。默认情况webpack和vite应该做它
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    // 在store上添加任何你设置的键
    store._customProperties.add('hello')
  }
})
```

Note that every store is wrapped with [`reactive`](https://v3.vuejs.org/api/basic-reactivity.html#reactive), automatically unwrapping any Ref (`ref()`, `computed()`, ...) it contains:
_注意，每个store都会被包裹在[`reactive`](https://v3.vuejs.org/api/basic-reactivity.html#reactive)，自动解开任何Ref（`ref()`, `computed()`, ...）它包含：_
```js
const sharedRef = ref('shared')
pinia.use(({ store }) => {
  // each store has its individual `hello` property
  // 每个store都有它自己的`hello`属性
  store.hello = ref('secret')
  // it gets automatically unwrapped
  // 这会被自动解开
  store.hello // 'secret'

  // all stores are sharing the value `shared` property
  // 所有store共享`shared`属性
  store.shared = sharedRef
  store.shared // 'shared'
})
```

This is why you can access all computed properties without `.value` and why they are reactive.
_这是为什么你可以不使用`.value`来访问所有计算属性，并且它们是反应性的_
### Adding new state

If you want to add new state properties to a store or properties that are meant to be used during hydration, **you will have to add it in two places**:
_如果你想要给store或者想要在同构时使用的属性，你需要在两处添加：_
- On the `store` so you can access it with `store.myState` _在store上你可以通过`store.myState`访问它_
- On `store.$state` so it can be used in devtools and, **be serialized during SSR**. _在store.$state上你可以访问它在devtools和，**在SSR时会被序列化**_

On top of that, you will certainly have to use a `ref()` (or other reactive API) in order to share the value across different accesses:
_在顶部，你必须使用`ref()`（或其他反应性API）来共享值：_
```js
import { toRef, ref } from 'vue'

pinia.use(({ store }) => {
  // to correctly handle SSR, we need to make sure we are not overriding an
  // existing value
  // 为了正确处理SSR，我们需要确保我们不会覆盖现有值
  if (!Object.prototype.hasOwnProperty(store.$state, 'hasError')) {
    // hasError is defined within the plugin, so each store has their individual
    // state property
    // hasError是在插件中定义的，所以每个store都有它自己的状态属性
    const hasError = ref(false)
    // setting the variable on `$state`, allows it be serialized during SSR
    // 设置它在`$state`，这样它可以在SSR时被序列化
    store.$state.hasError = hasError
  }
  // we need to transfer the ref from the state to the store, this way
  // both accesses: store.hasError and store.$state.hasError will work
  // and share the same variable
  // 我们需要将ref从状态传递给store，这样两个访问：store.hasError和store.$state.hasError都可以使用，并且共享相同的变量
  // See https://vuejs.org/api/reactivity-utilities.html#toref
  store.hasError = toRef(store.$state, 'hasError')

  // in this case it's better not to return `hasError` since it
  // will be displayed in the `state` section in the devtools
  // anyway and if we return it, devtools will display it twice.
  // 在这种情况下，我们不应该返回`hasError`，因为它将在devtools的`state`部分显示两次
})
```

Note that state changes or additions that occur within a plugin (that includes calling `store.$patch()`) happen before the store is active and therefore **do not trigger any subscriptions**.
_注意，在插件中（包括调用`store.$patch()`）发生的状态变化或添加（包括调用`store.$patch()`）**不会触发任何订阅**。_
:::warning
If you are using **Vue 2**, Pinia is subject to the [same reactivity caveats](https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats) as Vue. You will need to use `set` from `@vue/composition-api` when creating new state properties like `secret` and `hasError`:
_如果你使用**Vue 2**，Pinia将受到[同类型反应性问题](https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats)。你需要使用`set`来创建新的状态属性，如`secret`和`hasError`：_
```js
import { set, toRef } from '@vue/composition-api'
pinia.use(({ store }) => {
  if (!Object.prototype.hasOwnProperty(store.$state, 'hello')) {
    const secretRef = ref('secret')
    // If the data is meant to be used during SSR, you should
    // set it on the `$state` property so it is serialized and
    // picked up during hydration
    // 如果数据是在SSR时使用的，你应该将它设置在`$state`属性，这样它将被序列化并在同构时被提取
    set(store.$state, 'secret', secretRef)
  }
  // set it directly on the store too so you can access it
  // both ways: `store.$state.secret` / `store.secret`
  // 在store上直接设置它，这样你可以在两种方式：`store.$state.secret` / `store.secret`
  set(store, 'secret', toRef(store.$state, 'secret'))
  store.secret // 'secret'
})
```

:::

## Adding new external properties

When adding external properties, class instances that come from other libraries, or simply things that are not reactive, you should wrap the object with `markRaw()` before passing it to pinia. Here is an example adding the router to every store:
_当添加外部属性时，类实例来自其他库，或者只是不反应性的东西，你应该在传递之前使用`markRaw()`。这是一个例子，将路由添加到每个store：_
```js
import { markRaw } from 'vue'
// adapt this based on where your router is
// 基于你的路由在这里适配
import { router } from './router'

pinia.use(({ store }) => {
  store.router = markRaw(router)
})
```

## Calling `$subscribe` inside plugins

You can use [store.$subscribe](./state.md#subscribing-to-the-state) and [store.$onAction](./actions.md#subscribing-to-actions) inside plugins too:
_你可以在插件中使用[store.$subscribe](./state.md#subscribing-to-the-state)和[store.$onAction](./actions.md#subscribing-to-actions)：_
```ts
pinia.use(({ store }) => {
  store.$subscribe(() => {
    // react to store changes
    // 响应store变化
  })
  store.$onAction(() => {
    // react to store actions
    // 响应store动作
  })
})
```

## Adding new options

It is possible to create new options when defining stores to later on consume them from plugins. For example, you could create a `debounce` option that allows you to debounce any action:
_可以在定义store时创建新的选项，以便以后从插件中消费。例如，你可以创建一个`debounce`选项，允许你将任何动作debounce：_
```js
defineStore('search', {
  actions: {
    searchContacts() {
      // ...
    },
  },

  // this will be read by a plugin later on
  // 将被插件后面读取
  debounce: {
    // debounce the action searchContacts by 300ms
    // 延迟动作searchContacts 300ms
    searchContacts: 300,
  },
})
```

The plugin can then read that option to wrap actions and replace the original ones:
_插件可以读取这个选项，以便包装动作并替换原始动作：_
```js
// use any debounce library
import debounce from 'lodash/debounce'

pinia.use(({ options, store }) => {
  if (options.debounce) {
    // we are overriding the actions with new ones
    // 我们覆盖了动作 compose
    return Object.keys(options.debounce).reduce((debouncedActions, action) => {
      debouncedActions[action] = debounce(
        store[action],
        options.debounce[action]
      )
      return debouncedActions
    }, {})
  }
})
```

Note that custom options are passed as the 3rd argument when using the setup syntax:
_注意，自定义选项会作为第三个参数传递给setup语法：_
```js
defineStore(
  'search',
  () => {
    // ...
  },
  {
    // this will be read by a plugin later on
    // 将被插件后面读取
    debounce: {
      // debounce the action searchContacts by 300ms
      // 延迟动作searchContacts 300ms
      searchContacts: 300,
    },
  }
)
```

## TypeScript

Everything shown above can be done with typing support, so you don't ever need to use `any` or `@ts-ignore`.
_所有上面的都可以使用类型支持，所以你永远不需要使用`any`或`@ts-ignore`。_
### Typing plugins

A Pinia plugin can be typed as follows:
_一个Pinia插件可以如下类型：_
```ts
import { PiniaPluginContext } from 'pinia'

export function myPiniaPlugin(context: PiniaPluginContext) {
  // ...
}
```

### Typing new store properties

When adding new properties to stores, you should also extend the `PiniaCustomProperties` interface.
_当添加新的属性到store时，你应该同时扩展`PiniaCustomProperties`接口。_
```ts
import 'pinia'

declare module 'pinia' {
  export interface PiniaCustomProperties {
    // by using a setter we can allow both strings and refs
    // 使用setter，我们可以允许字符串和refs
    set hello(value: string | Ref<string>)
    get hello(): string

    // you can define simpler values too
    // 你也可以定义简单的值
    simpleNumber: number
  }
}
```

It can then be written and read safely:
_然后可以安全的写和读：_
```ts
pinia.use(({ store }) => {
  store.hello = 'Hola'
  store.hello = ref('Hola')

  store.simpleNumber = Math.random()
  // @ts-expect-error: we haven't typed this correctly
  store.simpleNumber = ref(Math.random())
})
```

`PiniaCustomProperties` is a generic type that allows you to reference properties of a store. Imagine the following example where we copy over the initial options as `$options` (this would only work for option stores):
_`PiniaCustomProperties`是一个泛型类型，允许你引用store的属性。假设我们将初始选项复制到`$options`（这只对选项store有效）：_
```ts
pinia.use(({ options }) => ({ $options: options }))
```

We can properly type this by using the 4 generic types of `PiniaCustomProperties`:
_我们可以通过使用`PiniaCustomProperties`的4个泛型类型来确定类型：_
```ts
import 'pinia'

declare module 'pinia' {
  export interface PiniaCustomProperties<Id, S, G, A> {
    $options: {
      id: Id
      state?: () => S
      getters?: G
      actions?: A
    }
  }
}
```

:::tip
When extending types in generics, they must be named **exactly as in the source code**. `Id` cannot be named `id` or `I`, and `S` cannot be named `State`. Here is what every letter stands for:
_在泛型中扩展类型时，它们必须与源代码中的名称完全一致。`Id`不能命名为`id`或`I`，`S`不能命名为`State`。这里是每个字母的含义：_
- S: State
- G: Getters
- A: Actions
- SS: Setup Store / Store

:::

### Typing new state

When adding new state properties (to both, the `store` and `store.$state`), you need to add the type to `PiniaCustomStateProperties` instead. Differently from `PiniaCustomProperties`, it only receives the `State` generic:
_当添加新的状态属性（到store和store.$state）时，你需要添加类型到`PiniaCustomStateProperties`，不同于`PiniaCustomProperties`，它只接收`State`泛型：_
```ts
import 'pinia'

declare module 'pinia' {
  export interface PiniaCustomStateProperties<S> {
    hello: string
  }
}
```

### Typing new creation options

When creating new options for `defineStore()`, you should extend the `DefineStoreOptionsBase`. Differently from `PiniaCustomProperties`, it only exposes two generics: the State and the Store type, allowing you to limit what can be defined. For example, you can use the names of the actions:
_当创建新的选项for`defineStore()`时，你应该扩展`DefineStoreOptionsBase`。不同于`PiniaCustomProperties`，它只公开两个泛型：状态和store类型，允许你限制可以定义。例如，你可以使用actions的名称：_
```ts
import 'pinia'

declare module 'pinia' {
  export interface DefineStoreOptionsBase<S, Store> {
    // allow defining a number of ms for any of the actions
    // 允许定义任意的ms的任何一个actions
    debounce?: Partial<Record<keyof StoreActions<Store>, number>>
  }
}
```

:::tip
There is also a `StoreGetters` type to extract the _getters_ from a Store type. You can also extend the options of _setup stores_ or _option stores_ **only** by extending the types `DefineStoreOptions` and `DefineSetupStoreOptions` respectively.
_有一个`StoreGetters`类型来提取store的_getters_。你也可以扩展_setup stores_或_option stores_的选项，只需扩展types`DefineStoreOptions`和`DefineSetupStoreOptions`。_
:::

## Nuxt.js

When [using pinia alongside Nuxt](../ssr/nuxt.md), you will have to create a [Nuxt plugin](https://nuxtjs.org/docs/2.x/directory-structure/plugins) first. This will give you access to the `pinia` instance:
_当使用pinia与Nuxt一起使用（ssr/nuxt.md），你需要先创建一个[Nuxt plugin](https://nuxtjs.org/docs/2.x/directory-structure/plugins)。这将会给你访问pinia实例：_
```ts
// plugins/myPiniaPlugin.js
import { PiniaPluginContext } from 'pinia'
import { Plugin } from '@nuxt/types'

function MyPiniaPlugin({ store }: PiniaPluginContext) {
  store.$subscribe((mutation) => {
    // react to store changes
    // 响应store变化
    console.log(`[🍍 ${mutation.storeId}]: ${mutation.type}.`)
  })

  // Note this has to be typed if you are using TS
  // 注意，如果你使用TS，这必须是类型化的
  return { creationTime: new Date() }
}

const myPlugin: Plugin = ({ $pinia }) => {
  $pinia.use(MyPiniaPlugin)
}

export default myPlugin
```

Note the above example is using TypeScript, you have to remove the type annotations `PiniaPluginContext` and `Plugin` as well as their imports if you are using a `.js` file.
_注意，上面的例子使用TypeScript，如果你使用了`.js`文件,你需要移除类型标注`PiniaPluginContext`和`Plugin`。_


# Using a store outside of a component

Pinia stores rely on the `pinia` instance to share the same store instance across all calls. Most of the time, this works out of the box by just calling your `useStore()` function. For example, in `setup()`, you don't need to do anything else. But things are a bit different outside of a component.
Behind the scenes, `useStore()` _injects_ the `pinia` instance you gave to your `app`. This means that if the `pinia` instance cannot be automatically injected, you have to manually provide it to the `useStore()` function.
You can solve this differently depending on the kind of application you are writing.
_Pinia 存储依赖于pinia实例来共享同一个store实例。大多数时候，这是通过调用你的useStore()函数来实现的。例如，在setup()中，你不需要做任何其他事情。但是，在一个组件之外，事情是有所不同的。_
## Single Page Applications

If you are not doing any SSR (Server Side Rendering), any call of `useStore()` after installing the pinia plugin with `app.use(pinia)` will work:
_如果你不是做任何SSR（服务器端渲染），在安装pinia插件后调用useStore()后，它将会工作：_
```js
import { useUserStore } from '@/stores/user'
import { createApp } from 'vue'
import App from './App.vue'

// ❌  fails because it's called before the pinia is created
// ❌  因为它在pinia创建之前被调用
const userStore = useUserStore()

const pinia = createPinia()
const app = createApp(App)
app.use(pinia)

// ✅ works because the pinia instance is now active
// ✅ 因为pinia实例现在已经激活
const userStore = useUserStore()
```

The easiest way to ensure this is always applied is to _defer_ calls of `useStore()` by placing them inside functions that will always run after pinia is installed.
_最简单的方法是通过将useStore()函数放在函数中，来保证它总是在pinia安装后才被调用。_
Let's take a look at this example of using a store inside of a navigation guard with Vue Router:
_看一下使用store在导航守卫中的例子：_
```js
import { createRouter } from 'vue-router'
const router = createRouter({
  // ...
})

// ❌ Depending on the order of imports this will fail
// ❌ 取决于导入的顺序，这将会失败
const store = useStore()

router.beforeEach((to, from, next) => {
  // we wanted to use the store here
  // 我们想要使用store这里
  if (store.isLoggedIn) next()
  else next('/login')
})

router.beforeEach((to) => {
  // ✅ This will work because the router starts its navigation after
  // the router is installed and pinia will be installed too
  // ✅ 这将会工作，因为路由开始导航之后，pinia也会被安装
  const store = useStore()

  if (to.meta.requiresAuth && !store.isLoggedIn) return '/login'
})
```

## SSR Apps

When dealing with Server Side Rendering, you will have to pass the `pinia` instance to `useStore()`. This prevents pinia from sharing global state between different application instances.
_在服务器端渲染的应用中，你需要传递pinia实例给useStore()。这将阻止pinia在不同应用实例之间共享全局状态。_
There is a whole section dedicated to it in the [SSR guide](/ssr/index.md), this is just a short explanation:
_在[SSR指南](/ssr/index.md)中有一个专门的章节，这只是一个简短的说明：_

# 手册

# Usage without `setup()`

Pinia can be used even if you are not using the composition API (if you are using Vue 2, you still need to install the `@vue/composition-api` plugin though). While we recommend you to give the Composition API a try and learn it, it might not be the time for you and your team yet, you might be in the process of migrating an application, or any other reason. There are a few functions:
_Pinia可以被使用，即使你不使用组合API（如果你使用Vue 2，你仍然需要安装`@vue/composition-api`插件）。但是我们建议你试一试组合API，然后学习它，非团队合作，你可能正在迁移一个应用，或者其他任何原因。有一些函数：_
- [mapStores](#giving-access-to-the-whole-store)
- [mapState](../core-concepts/state.md#options-api)
- [mapWritableState](../core-concepts/state.md#modifiable-state)
- ⚠️ [mapGetters](../core-concepts/getters.md#options-api) (just for migration convenience, use `mapState()` instead)
- [mapActions](../core-concepts/actions.md#options-api)

## Giving access to the whole store

If you need to access pretty much everything from the store, it might be too much to map every single property of the store... Instead you can get access to the whole store with `mapStores()`:
_如果你需要访问整个store，可能会太多了，可以使用mapStores()来访问整个store：_
```js
import { mapStores } from 'pinia'

// given two stores with the following ids
// 给定两个store，其id为：
const useUserStore = defineStore('user', {
  // ...
})
const useCartStore = defineStore('cart', {
  // ...
})

export default {
  computed: {
    // note we are not passing an array, just one store after the other
    // each store will be accessible as its id + 'Store'
    // 注意我们不传递数组，而是一个store一个store
    ...mapStores(useCartStore, useUserStore)
  },

  methods: {
    async buyStuff() {
      // use them anywhere!
      // 使用它们任何地方！
      if (this.userStore.isAuthenticated()) {
        await this.cartStore.buy()
        this.$router.push('/purchased')
      }
    },
  },
}
```

By default, Pinia will add the `"Store"` suffix to the `id` of each store. You can customize this behavior by calling the `setMapStoreSuffix()`:
_默认情况下，Pinia将添加“Store”后缀到每个store的id。你可以通过调用setMapStoreSuffix()来自定义这个行为：_
```js
import { createPinia, setMapStoreSuffix } from 'pinia'

// completely remove the suffix: this.user, this.cart
// 完全删除后缀：this.user, this.cart
setMapStoreSuffix('')
// this.user_store, this.cart_store (it's okay, I won't judge you)
// 这个user_store, this.cart_store（也是可以的）

setMapStoreSuffix('_store')
export const pinia = createPinia()
```

## TypeScript

By default, all map helpers support autocompletion and you don't need to do anything. If you call `setMapStoreSuffix()` to change the `"Store"` suffix, you will need to also add it somewhere in a TS file or your `global.d.ts` file. The most convenient place would be the same place where you call `setMapStoreSuffix()`:
_默认情况下，所有map helpers都支持自动完成，你不需要做任何事情。如果你调用setMapStoreSuffix()来改变“Store”后缀，你还需要在TS文件或你的global.d.ts文件中添加它。最方便的地方就是在你调用setMapStoreSuffix()的地方：_
```ts
import { createPinia, setMapStoreSuffix } from 'pinia'
// completely remove the suffix
// 完全删除后缀
setMapStoreSuffix('') 

export const pinia = createPinia()

declare module 'pinia' {
  export interface MapStoresCustomization {
    // set it to the same value as above
    // 设置为上面的值
    suffix: ''
  }
}
```

:::warning
If you are using a TypeScript declaration file (like `global.d.ts`), make sure to `import 'pinia'` at the top of it to expose all existing types.
_如果你使用了一个TypeScript声明文件（例如`global.d.ts`），请在它的顶部导入`pinia`来对所有现有类型进行暴露。_
:::

# Composing Stores

Composing stores is about having stores that use each other and there is one rule to follow:
_组合store是关于有store使用另一个store的事情，有一条规则要遵守：_
If **two or more stores use each other**, they cannot create an infinite loop through _getters_ or _actions_. They cannot **both** directly read each other state in their setup function:
_如果两个或多个store使用了另一个store，那么它们不能通过_getters_或_actions_创建无限循环。它们不能同时直接读取另一个store的状态：_
```js
const useX = defineStore('x', () => {
  const y = useY()

  // ❌ This is not possible because y also tries to read x.name
  // ❌ 这是不可能的，因为y也试图读取x的name
  y.name

  function doSomething() {
    // ✅ Read y properties in computed or actions
    // ✅ 读取y属性在computed或actions
    const yName = y.name
    // ...
  }

  return {
    name: ref('I am X'),
  }
})

const useY = defineStore('y', () => {
  const x = useX()

  // ❌ This is not possible because x also tries to read y.name
  // ❌ 这是不可能的，因为x也试图读取y的name
  x.name

  function doSomething() {
    // ✅ Read x properties in computed or actions
    // ✅ 读取x属性在computed或actions
    const xName = x.name
    // ...
  }

  return {
    name: ref('I am Y'),
  }
})
```

## Nested stores

Note that if one store uses another store, **there is no need to create a new store in a separate file**, you can directly import it. Think of it as nesting.
_如果一个store使用另一个store，**不需要在一个单独的文件中创建一个新的store**，你可以直接导入它。记住它是嵌套的。_
You can call `useOtherStore()` at the top of any getter or action:
_你可以在任何getter或action的顶部调用useOtherStore()：_
```js
import { useUserStore } from './user'

export const cartStore = defineStore('cart', {
  getters: {
    // ... other getters
    summary(state) {
      const user = useUserStore()

      return `Hi ${user.name}, you have ${state.list.length} items in your cart. It costs ${state.price}.`
    },
  },

  actions: {
    purchase() {
      const user = useUserStore()

      return apiPurchase(user.id, this.list)
    },
  },
})
```

## Shared Getters

You can simply call `useOtherStore()` inside a _getter_:
_你可以在_getter_中直接调用useOtherStore()：_
```js
import { defineStore } from 'pinia'
import { useUserStore } from './user'

export const useCartStore = defineStore('cart', {
  getters: {
    summary(state) {
      const user = useUserStore()

      return `Hi ${user.name}, you have ${state.list.length} items in your cart. It costs ${state.price}.`
    },
  },
})
```

## Shared Actions

The same applies to _actions_:
_同样适用于_actions_：_

```js
import { defineStore } from 'pinia'
import { useUserStore } from './user'

export const useCartStore = defineStore('cart', {
  actions: {
    async orderCart() {
      const user = useUserStore()

      try {
        await apiOrderCart(user.token, this.items)
        // another action
        this.emptyCart()
      } catch (err) {
        displayError(err)
      }
    },
  },
})
```