---
title: Vue Pinia
date: 2022-06-10 17:21:00
categories:
tags: []
cover: http://t-blog-images.aijs.top/img/20220610172420.webp
---

## Pinia 特点

**💡 Intuitive**
`直观的`
Stores are as familiar as components. API designed to let you write well organized stores.
`存储和组件是一样的。API设计了让你写好组织的存储。`

**🔑 Type Safe**
`类型安全的`
Types are inferred, which means stores provide you with autocompletion even in JavaScript!
`类型可推测，这意味着存储提供了你在JavaScript中自动完成的功能！`

**⚙️ Devtools support**
`开发工具支持`
Pinia hooks into Vue devtools to give you an enhanced development experience in both Vue 2 and Vue 3.
`Pinia钩子进入Vue开发工具，让你在Vue 2和Vue 3中获得强化开发经验。`

**🔌 Extensible**
`可扩展的`
React to store changes to extend Pinia with transactions, local storage synchronization, etc.
`React到存储更改，扩展Pinia事务，本地存储同步，等等。`

**🏗 Modular by design**
`设计模块化`
Build multiple stores and let your bundler code split them automatically.
`构建多个存储，让你的bundler代码分开它们自动。`

**📦 Extremely light**
`非常轻量的`
Pinia weighs around 1kb, you will forget it's even there!
`Pinia重量约1kb，你会忘记它在那里！`

## Introduction

`介绍`

<VueSchoolLink
  href="https://vueschool.io/lessons/introduction-to-pinia"
  title="Get started with Pinia"
/>

Pinia [started](https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e) as an experiment to redesign what a Store for Vue could look like with the [Composition API](https://github.com/vuejs/composition-api) around November 2019. Since then, the initial principles are still the same, but Pinia works for both Vue 2 and Vue 3 **and doesn't require you to use the composition API**. The API is the same for both except for _installation_ and _SSR_, and these docs are targeted to Vue 3 **with notes about Vue 2** whenever necessary so it can be read by Vue 2 and Vue 3 users!

_译：Pinia 从 2019 年 11 月左右开始尝试重新设计 Vue store 的合成 API。从那时起，最初的原则仍然是一样的，但 Pinia 同时适用于 Vue 2 和 Vue 3，不需要您使用合成 API。除了安装和 SSR 之外，这两个 API 都是相同的，这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的说明，以便 Vue 2 和 Vue 3 用户可以阅读！_

**Why should I use Pinia?**

`为什么我应该使用Pinia？`

Pinia is a store library for Vue, it allows you to share a state across components/pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple `export const state = reactive({})`. This is true for single page applications but **exposes your application to [security vulnerabilities](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)** if it is server side rendered. But even in small single page applications, you get a lot from using Pinia:

_译：Pinia 是一个 Vue 的存储库，它允许你在组件/页面之间共享状态。如果你熟悉合成 API，你可能会认为你可以通过简单的`export const state = reactive({})`共享全局状态。这是对于单页应用的真实情况，但_ **如果它是服务器端渲染，它会暴露您的应用程序到[安全漏洞](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)**。_但即使是小的单页应用，使用 Pinia 也很多：_

- Devtools support _开发工具支持_
  - A timeline to track actions, mutations _追踪行动、突变的时间表_
  - Stores appear in components where they are used _存储出现在使用它们的组件中_
  - Time travel and easier debugging _时间旅行和更容易调试_
- Hot module replacement _快速更新_
  - Modify your stores without reloading your page _在不重新加载页面的情况下修改你的存储_
  - Keep any existing state while developing _在开发时保持任何现有状态_
- Plugins: extend Pinia features with plugins _功能扩展：使用插件扩展 Pinia 功能_
- Proper TypeScript support or **autocompletion** for JS users \*对于 JS 用户的正确的 TypeScript 支持或**自动完成\***
- Server Side Rendering Support _完美的服务器端渲染支持_

**Basic example**

`基本示例`
This is what using pinia looks like in terms of API (make sure to check the [Getting Started](./getting-started.md) for complete instructions). You start by creating a store:
_译：这是为什么使用 pinia 看起来像 API（请检查[开始](./getting-started.md)以获取完整的指令）。你首先创建一个存储：_

```js
// stores/counter.js
import { defineStore } from "pinia";

export const useCounterStore = defineStore("counter", {
  state: () => {
    return { count: 0 };
  },
  // could also be defined as
  // state: () => ({ count: 0 })
  actions: {
    increment() {
      this.count++;
    },
  },
});
```

And then you _use_ it in a component:
_译：然后你在组件中`使用`它：_

```js
import { useCounterStore } from "@/stores/counter";

export default {
  setup() {
    const counter = useCounterStore();

    counter.count++;
    // with autocompletion ✨
    counter.$patch({ count: counter.count + 1 });
    // or using an action instead
    counter.increment();
  },
};
```

You can even use a function (similar to a component `setup()`) to define a Store for more advanced use cases:
_译：你也可以使用函数（与组件`setup()`相似）来定义一个存储以更高级的使用情况：_

```js
export const useCounterStore = defineStore("counter", () => {
  const count = ref(0);
  function increment() {
    count.value++;
  }

  return { count, increment };
});
```

If you are still not into `setup()` and Composition API, don't worry, Pinia also support a similar set of [_map helpers_ like Vuex](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper). You define stores the same way but then use `mapStores()`, `mapState()`, or `mapActions()`:
_译：如果你还不是`setup()`和 Composition API 的熟悉，不用担心，Pinia 也支持[Vuex 的*map helpers*（如 Vuex）](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper)。你定义存储的方式相同，然后使用`mapStores()`, `mapState()`,或`mapActions()`：_

```js
const useCounterStore = defineStore("counter", {
  state: () => ({ count: 0 }),
  getters: {
    double: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++;
    },
  },
});

const useUserStore = defineStore("user", {
  // ...
});

export default {
  computed: {
    // other computed properties
    // ...
    // gives access to this.counterStore and this.userStore
    ...mapStores(useCounterStore, useUserStore),
    // gives read access to this.count and this.double
    ...mapState(useCounterStore, ["count", "double"]),
  },
  methods: {
    // gives access to this.increment()
    ...mapActions(useCounterStore, ["increment"]),
  },
};
```

You will find more information about each _map helper_ in the core concepts.
_译：你将找到更多关于每个*map helper*的信息。_

**Why _Pinia_**

_为什么叫 Pinia_

Pinia (pronounced `/piːnjʌ/`, like "peenya" in English) is the closest word to _piña_ (_pineapple_ in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It's also a delicious tropical fruit indigenous to South America.

_Pinia 发音 `/piːnjʌ/`，类似于英语中的“柠檬”，它是一个有效的包名。一个柠檬是实际上是一组单个花朵结合在一起，以创建多个水果。与存储相似，每一个都是单独出生的，但是他们都是最终连接在一起的。它也是一个在南美洲的美食。_

**A more realistic example**

_译：更真实的例子_
Here is a more complete example of the API you will be using with Pinia **with types even in JavaScript**. For some people, this might be enough to get started without reading further but we still recommend checking the rest of the documentation or even skipping this example and coming back once you have read about all of the _Core Concepts_.
_译：这是一个更完整的例子，你将使用 Pinia**类型在 JavaScript**。对于一些人，这可能是足够开始而不需要阅读更多，但我们仍然建议检查其余的文档或跳过这个例子，然后回来一次你已经阅读了所有的**核心概念**。_

```js
import { defineStore } from "pinia";

export const todos = defineStore("todos", {
  state: () => ({
    /** @type {{ text: string, id: number, isFinished: boolean }[]} */
    todos: [],
    /** @type {'all' | 'finished' | 'unfinished'} */
    filter: "all",
    // type will be automatically inferred to number
    // 类型将自动推断为number
    nextId: 0,
  }),
  getters: {
    finishedTodos(state) {
      // autocompletion! ✨
      // 自动完成
      return state.todos.filter((todo) => todo.isFinished);
    },
    unfinishedTodos(state) {
      return state.todos.filter((todo) => !todo.isFinished);
    },
    /**
     * @returns {{ text: string, id: number, isFinished: boolean }[]}
     */
    filteredTodos(state) {
      if (this.filter === "finished") {
        // call other getters with autocompletion ✨
        // 调用其他getters自动完成
        return this.finishedTodos;
      } else if (this.filter === "unfinished") {
        return this.unfinishedTodos;
      }
      return this.todos;
    },
  },
  actions: {
    // any amount of arguments, return a promise or not
    // 任意数量的参数，返回一个promise或不
    addTodo(text) {
      // you can directly mutate the state
      // 你可以直接修改状态
      this.todos.push({ text, id: this.nextId++, isFinished: false });
    },
  },
});
```

**Comparison with Vuex**

_译：与 Vuex 比较_

Pinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.
_译：Pinia 开始了一个探索 Vuex 的下一个迭代，并且将大量的想法从 Vuex 5 的核心团队讨论中提取。最终，我们认为 Pinia 已经实现了大部分我们想要的 Vuex 5，并且决定改变它的推荐。_
Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.
_译：与 Vuex 比较，Pinia 提供了更简单的 API，提供了组合 API 的 API，并且在使用 TypeScript 时有实体类型支持。_

**RFCs**

_译：RFCs_

> RFCs 涵盖了 Vue 的最基本的四个部分，截至目前为止，已经有 38 个 PR 提交（26 个仍在讨论中），这些提议中既有 Vue 作者自己的提议，也有开发者的提议。
>
> - Vue core
> - Vue Router
> - Vuex
> - Vue CLI

Initially Pinia didn't go through any RFC. I tested out ideas based on my experience developing applications, reading other people's code, working for clients who use Pinia, and answering questions on Discord.
This allowed me to provide a solution that works and is adapted to a variety of cases and application sizes. I used to publish often and made the library evolve while keeping its core API the same.
_译：初始 Pinia 没有通过任何 RFC。我测试了基于我的经验开发应用程序，阅读其他人的代码，为使用 Pinia 的客户工作，并在 Discord 上回答问题。这让我提供了一个解决方案，它工作并适合各种情况和应用程序大小。我经常发布，并在保持核心 API 相同的情况下，使库发展。_
Now that Pinia has become the default state management solution, it is subject to the same RFC process as other core libraries in the Vue ecosystem and its API has entered a stable state.
_译：现在，Pinia 已经成为 Vue 的核心状态管理解决方案，它与 Vue 社区中其他核心库的 RFC 进行了相同的处理，并且它的 API 已经进入了一个稳定状态。_

**Comparison with Vuex 3.x/4.x**

_译：与 Vuex 3.x/4.x 比较_

> Vuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3
> Vuex 3.x 是 Vuex 2 的 Vuex，而 Vuex 4.x 是 Vue 3 的 Vuex
> Pinia API is very different from Vuex ≤4, namely:
> _译：Pinia API 与 Vuex 3.x/4.x 比较，主要区别是：_

- _mutations_ no longer exist. They were very often perceived as **_extremely_ verbose**. They initially brought devtools integration but that is no longer an issue.
  `- mutations 不再存在。它们初始上抛了开发工具集成，但这不再是问题。`
- No need to create custom complex wrappers to support TypeScript, everything is typed and the API is designed in a way to leverage TS type inference as much as possible.
  `- 没有需要创建自定义复杂的包装来支持TypeScript，所有的都是类型化的，API设计了一个让你最大限度地利用TS类型推断的方式。`
- No more magic strings to inject, import the functions, call them, enjoy autocompletion!
  `- 没有更多的魔法字符串注入，导入函数，调用它们，享受自动完成！`
- No need to dynamically add stores, they are all dynamic by default and you won't even notice. Note you can still manually use a store to register it whenever you want but because it is automatic you don't need to worry about it.
  `- 没有需要动态添加存储，它们都是默认的动态的，你也不会发现。请注意，你仍然可以手动使用存储来注册它，但是因为它是自动的，你不需要担心它。`
- No more nested structuring of _modules_. You can still nest stores implicitly by importing and _using_ a store inside another but Pinia offers a flat structuring by design while still enabling ways of cross composition among stores. **You can even have circular dependencies of stores**.
  `- 没有更多的嵌套结构的_模块_。你仍然可以嵌套存储通过导入并使用存储在另一个存储中，但Pinia提供了一个平面的结构，而且还允许在存储之间跨越组合。**你还可以有圆形依赖的存储**。`
- No _namespaced modules_. Given the flat architecture of stores, "namespacing" stores is inherent to how they are defined and you could say all stores are namespaced.
  `- 没有_命名空间模块_。给定存储的平面建构，“命名空间”存储是因为它们定义的方式而具有的，你可以说所有的存储都是命名空间。`
  For more detailed instructions on how to convert an existing Vuex ≤4 project to use Pinia, see the [Migration from Vuex Guide](./cookbook/migration-vuex.md).
  _译：为了更加详细的指导如何将现有的 Vuex ≤4 项目转换为使用 Pinia，请参阅[Migration from Vuex Guide](./cookbook/migration-vuex.md)。_

## [起步](https://pinia.vuejs.org/getting-started.html#installation)

### Installation

Install `pinia` with your favorite package manager:
_译：使用你喜欢的包管理器安装 `pinia` ：_

```bash
yarn add pinia
# or with npm
npm install pinia
```

:::tip
If your app is using Vue 2, you also need to install the composition api: `@vue/composition-api`. If you are using Nuxt, you should follow [these instructions](https://pinia.vuejs.org/ssr/nuxt.html).
_译：如果你的应用使用 Vue 2，你还需要安装组合 api：`@vue/composition-api`。如果你使用 Nuxt，你应该遵循[这些指导](https://pinia.vuejs.org/ssr/nuxt.html)。_
:::

If you are using the Vue CLI, you can instead give this [**unofficial plugin**](https://github.com/wobsoriano/vue-cli-plugin-pinia) a try.
\_译：如果你使用 Vue CLI，你可以试试这个 [**非官方插件**](

Create a pinia (the root store) and pass it to the app:
_译：创建一个 pinia （根存储）并将其传递给应用：_

```js
import { createPinia } from "pinia";

app.use(createPinia());
```

If you are using Vue 2, you also need to install a plugin and inject the created `pinia` at the root of the app:
_译：如果你使用 Vue 2，你还需要安装一个插件并将创建的 `pinia` 注入到应用的根中：_

```js
import { createPinia, PiniaVuePlugin } from "pinia";

Vue.use(PiniaVuePlugin);
const pinia = createPinia();

new Vue({
  el: "#app",
  // other options...
  // ...
  // note the same `pinia` instance can be used across multiple Vue apps on the same page
  // 注意，同一个 `pinia` 实例可以在同一个页面上的多个 Vue 应用中使用
  pinia,
});
```

This will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn't expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).
_译：这也会添加 devtools 支持。在 Vue 3 中，某些功能（例如时间旅行和编辑）仍然不支持，因为 vue-devtools 不暴露了必要的 API，但是 devtools 有更多的功能，开发者体验整体更优。在 Vue 2 中，Pinia 使用现有的 Vuex 接口（因此不能与它一起使用）。_

### What is a Store?

A Store (like Pinia) is an entity holding state and business logic that isn't bound to your Component tree. In other words, **it hosts global state**. It's a bit like a component that is always there and that everybody can read off and write to. It has **three concepts**, the [state](./core-concepts/state.md), [getters](./core-concepts/getters.md) and [actions](./core-concepts/actions.md) and it's safe to assume these concepts are the equivalent of `data`, `computed` and `methods` in components.
_译：一个存储（像 Pinia）是一个持有状态和业务逻辑的实体，它不是绑定到你的组件树上的。也就是说，**它持有全局状态**。它是一个总是存在的组件，每个人都可以读取并写入。它有 **三个概念**，[state](./core-concepts/state.md)，[getters](./core-concepts/getters.md) 和 [actions](./core-concepts/actions.md)，并且我们假设这三个概念是组件的 `data`，`computed` 和 `methods` 的等价。_

### When should I use a Store

A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.
_译：一个存储应该包含可以在整个应用程序中访问的数据。这包括在多个地方使用的数据，例如在导航栏中显示的用户信息，以及需要在页面中保留的数据，例如一个复杂的多步骤表单。_
On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.
_译：另一方面，你应该避免在存储中包含在组件中存储的本地数据，例如页面中的一个元素的可见性。_
Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.
_译：不是所有应用都需要访问全局状态，但如果你的应用需要一个，Pinia 将使你的生活更加方便。_

## 核心概念

### Store

**Defining a Store**

<VueSchoolLink
  href="https://vueschool.io/lessons/define-your-first-pinia-store"
  title="Learn how to define and use stores in Pinia"
/>

Before diving into core concepts, we need to know that a store is defined using `defineStore()` and that it requires a **unique** name, passed as the first argument:
_译：在深入核心概念之前，我们需要知道一个存储由 `defineStore()` 定义并且需要一个 **唯一的** 名称作为第一个参数：_

```js
import { defineStore } from "pinia";

// useStore could be anything like useUser, useCart
// the first argument is a unique id of the store across your application
export const useStore = defineStore("main", {
  // other options...
});
```

This _name_, also referred as _id_, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function _use..._ is a convention across composables to make its usage idiomatic.
_译：这个名称，也称为 _id_，是必需的并且用于连接存储到 devtools。命名返回的函数 _use..._ 是一个组合使用的惯例，使用它的用法简单易懂。_
**Using the store**

We are _defining_ a store because the store won't be created until `useStore()` is called inside of `setup()`:
_译：我们正在定义一个存储，因为只有在`setup（）`内部调用`useStore（）`才能创建该存储_

```js
import { useStore } from "@/stores/counter";

export default {
  setup() {
    const store = useStore();

    return {
      // you can return the whole store instance to use it in the template
      // 你可以在模板中返回整个存储实例来使用它
      store,
    };
  },
};
```

You can define as many stores as you want and **you should define each store in a different file** to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).
_译 ：你可以定义多个存储，你应该在不同的文件中定义每个存储来获得 pinia 的最大效用（例如自动允许你的 bundle 分割和 TypeScript 推断）。_
If you are not using `setup` components yet, [you can still use Pinia with _map helpers_](https://pinia.vuejs.org/cookbook/options-api.html).
_译：如果你还没有使用 `setup` 组件，你仍然可以使用 Pinia 与 [map 助手]（https://pinia.vuejs.org/cookbook/options-api.html）。_
Once the store is instantiated, you can access any property defined in `state`, `getters`, and `actions` directly on the store. We will see these in detail in the next pages but autocompletion will help you.
_译：一旦存储被实例化，你可以直接在存储上访问 `state`，`getters` 和 `actions` 中定义的属性。我们将在下一页中详细讲解，但是自动补全将帮助你。_
Note that `store` is an object wrapped with `reactive`, meaning there is no need to write `.value` after getters but, like `props` in `setup`, **we cannot destructure it**:
_译：请注意，存储是一个 `reactive` 包装的对象，因此不需要写 `.value` 后面的 getters，但是，像 `setup` 中的 `props`，我们不能解构它_

```js
export default defineComponent({
  setup() {
    const store = useStore();
    // ❌ This won't work because it breaks reactivity it's the same as destructuring from `props`
    // 这不会工作，因为它会破坏可观察性，它是相同的为 `props` 构造的
    const { name, doubleCount } = store;

    name; // "eduardo"
    doubleCount; // 2

    return {
      // will always be "eduardo"
      // 将始终是 "eduardo"
      name,
      // will always be 2
      // 将始终是 2
      doubleCount,
      // this one will be reactive
      // 这个将是可观察的
      doubleValue: computed(() => store.doubleCount),
    };
  },
});
```

In order to extract properties from the store while keeping its reactivity, you need to use `storeToRefs()`. It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:
_译：为了从存储中提取属性而保持其可观察性，你需要使用 `storeToRefs()`。它会创建每个可观察属性的 ref。这对于只使用存储中的状态但不调用任何行为时非常有用。请注意，你可以直接从存储中解构 actions，因为它们都是绑定到存储本身的。_

```js
import { storeToRefs } from "pinia";

export default defineComponent({
  setup() {
    const store = useStore();
    // `name` and `doubleCount` are reactive refs
    // This will also create refs for properties added by plugins
    // but skip any action or non reactive (non ref/reactive) property
    const { name, doubleCount } = storeToRefs(store);
    // the increment action can be just extracted
    const { increment } = store;

    return {
      name,
      doubleCount,
      increment,
    };
  },
});
```

### State

<VueSchoolLink
  href="https://vueschool.io/lessons/access-state-from-a-pinia-store"
  title="Learn all about state in Pinia"
/>

The state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.
_大多数时候，state是你store的中心。人们通常从定义代表其应用程序的状态开始。在Pinia中，状态定义为返回初始状态的函数。这允许Pinia在服务器端和客户端都工作。_
```js
import { defineStore } from "pinia";

const useStore = defineStore("storeId", {
  // arrow function recommended for full type inference
  state: () => {
    return {
      // all these properties will have their type inferred automatically
      counter: 0,
      name: "Eduardo",
      isAdmin: true,
    };
  },
});
```

:::tip
If you are using Vue 2, the data you create in `state` follows the same rules as the `data` in a Vue instance, ie the state object must be plain and you need to call `Vue.set()` when **adding new** properties to it. **See also: [Vue#data](https://v2.vuejs.org/v2/api/#data)**.
:::

**Accessing the `state`**

By default, you can directly read and write to the state by accessing it through the `store` instance:

```js
const store = useStore();

store.counter++;
```

**Resetting the state**

You can _reset_ the state to its initial value by calling the `$reset()` method on the store:

```js
const store = useStore();

store.$reset();
```

**Usage with the Options API**

<VueSchoolLink
  href="https://vueschool.io/lessons/access-pinia-state-in-the-options-api"
  title="Access Pinia State via the Options API"
/>

For the following examples, you can assume the following store was created:

```js
// Example File Path:
// ./src/stores/counterStore.js

import { defineStore } from "pinia";

const useCounterStore = defineStore("counterStore", {
  state: () => ({
    counter: 0,
  }),
});
```

If you are not using the Composition API, and you are using `computed`, `methods`, ..., you can use the `mapState()` helper to map state properties as readonly computed properties:

```js
import { mapState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component
    // same as reading from store.counter
    ...mapState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapState(useCounterStore, {
      myOwnName: 'counter',
      // you can also write a function that gets access to the store
      double: store => store.counter * 2,
      // it can have access to `this` but it won't be typed correctly...
      magicValue(store) {
        return store.someGetter + this.counter + this.double
      },
    }),
  },
}
```

**Modifiable state**

If you want to be able to write to these state properties (e.g. if you have a form), you can use `mapWritableState()` instead. Note you cannot pass a function like with `mapState()`:

```js
import { mapWritableState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component and allows setting it
    // this.counter++
    // same as reading from store.counter
    ...mapWritableState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapWritableState(useCounterStore, {
      myOwnName: 'counter',
    }),
  },
}
```

:::tip
You don't need `mapWritableState()` for collections like arrays unless you are replacing the whole array with `cartItems = []`, `mapState()` still allows you to call methods on your collections.
:::

**Mutating the state**

<!-- TODO: disable this with `strictMode` -->

Apart from directly mutating the store with `store.counter++`, you can also call the `$patch` method. It allows you to apply multiple changes at the same time with a partial `state` object:

```js
store.$patch({
  counter: store.counter + 1,
  name: "Abalam",
});
```

However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the `$patch` method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:

```js
cartStore.$patch((state) => {
  state.items.push({ name: "shoes", quantity: 1 });
  state.hasChanged = true;
});
```

<!-- TODO: disable this with `strictMode`, `{ noDirectPatch: true }` -->

The main difference here is that `$patch()` allows you to group multiple changes into one single entry in the devtools. Note **both, direct changes to `state` and `$patch()` appear in the devtools** and can be time travelled (not yet in Vue 3).

**Replacing the `state`**

You can replace the whole state of a store by setting its `$state` property to a new object:

```js
store.$state = { counter: 666, name: "Paimon" };
```

You can also replace the whole state of your application by changing the `state` of the `pinia` instance. This is used during [SSR for hydration](../ssr/#state-hydration).

```js
pinia.state.value = {};
```

**Subscribing to the state**

You can watch the state and its changes through the `$subscribe()` method of a store, similar to Vuex's [subscribe method](https://vuex.vuejs.org/api/#subscribe). The advantage of using `$subscribe()` over a regular `watch()` is that _subscriptions_ will trigger only once after _patches_ (e.g. when using the function version from above).

```js
cartStore.$subscribe((mutation, state) => {
  // import { MutationType } from 'pinia'
  mutation.type; // 'direct' | 'patch object' | 'patch function'
  // same as cartStore.$id
  mutation.storeId; // 'cart'
  // only available with mutation.type === 'patch object'
  mutation.payload; // patch object passed to cartStore.$patch()

  // persist the whole state to the local storage whenever it changes
  localStorage.setItem("cart", JSON.stringify(state));
});
```

By default, _state subscriptions_ are bound to the component where they are added (if the store is inside a component's `setup()`). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass `{ detached: true }` as the second argument to _detach_ the _state subscription_ from the current component:

```js
export default {
  setup() {
    const someStore = useSomeStore();

    // this subscription will be kept after the component is unmounted
    someStore.$subscribe(callback, { detached: true });

    // ...
  },
};
```

:::tip
You can watch the whole state on the `pinia` instance:
你可以监听整个pinia实例的状态，这个状态是一个对象，包含了所有的store的状态。

```js
watch(
  pinia.state,
  (state) => {
    // persist the whole state to the local storage whenever it changes
    localStorage.setItem("piniaState", JSON.stringify(state));
  },
  { deep: true }
);
```

:::
