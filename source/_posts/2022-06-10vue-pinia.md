---
title: Vue Pinia
date: 2022-06-10 17:21:00
categories:
tags: []
cover: http://t-blog-images.aijs.top/img/20220610172420.webp
---

## Pinia ç‰¹ç‚¹

**ğŸ’¡ Intuitive**
`ç›´è§‚çš„`
Stores are as familiar as components. API designed to let you write well organized stores.
`å­˜å‚¨å’Œç»„ä»¶æ˜¯ä¸€æ ·çš„ã€‚APIè®¾è®¡äº†è®©ä½ å†™å¥½ç»„ç»‡çš„å­˜å‚¨ã€‚`

**ğŸ”‘ Type Safe**
`ç±»å‹å®‰å…¨çš„`
Types are inferred, which means stores provide you with autocompletion even in JavaScript!
`ç±»å‹å¯æ¨æµ‹ï¼Œè¿™æ„å‘³ç€å­˜å‚¨æä¾›äº†ä½ åœ¨JavaScriptä¸­è‡ªåŠ¨å®Œæˆçš„åŠŸèƒ½ï¼`

**âš™ï¸ Devtools support**
`å¼€å‘å·¥å…·æ”¯æŒ`
Pinia hooks into Vue devtools to give you an enhanced development experience in both Vue 2 and Vue 3.
`Piniaé’©å­è¿›å…¥Vueå¼€å‘å·¥å…·ï¼Œè®©ä½ åœ¨Vue 2å’ŒVue 3ä¸­è·å¾—å¼ºåŒ–å¼€å‘ç»éªŒã€‚`

**ğŸ”Œ Extensible**
`å¯æ‰©å±•çš„`
React to store changes to extend Pinia with transactions, local storage synchronization, etc.
`Reactåˆ°å­˜å‚¨æ›´æ”¹ï¼Œæ‰©å±•Piniaäº‹åŠ¡ï¼Œæœ¬åœ°å­˜å‚¨åŒæ­¥ï¼Œç­‰ç­‰ã€‚`

**ğŸ— Modular by design**
`è®¾è®¡æ¨¡å—åŒ–`
Build multiple stores and let your bundler code split them automatically.
`æ„å»ºå¤šä¸ªå­˜å‚¨ï¼Œè®©ä½ çš„bundlerä»£ç åˆ†å¼€å®ƒä»¬è‡ªåŠ¨ã€‚`

**ğŸ“¦ Extremely light**
`éå¸¸è½»é‡çš„`
Pinia weighs around 1kb, you will forget it's even there!
`Piniaé‡é‡çº¦1kbï¼Œä½ ä¼šå¿˜è®°å®ƒåœ¨é‚£é‡Œï¼`

## Introduction

`ä»‹ç»`

<VueSchoolLink
  href="https://vueschool.io/lessons/introduction-to-pinia"
  title="Get started with Pinia"
/>

Pinia [started](https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e) as an experiment to redesign what a Store for Vue could look like with the [Composition API](https://github.com/vuejs/composition-api) around November 2019. Since then, the initial principles are still the same, but Pinia works for both Vue 2 and Vue 3 **and doesn't require you to use the composition API**. The API is the same for both except for _installation_ and _SSR_, and these docs are targeted to Vue 3 **with notes about Vue 2** whenever necessary so it can be read by Vue 2 and Vue 3 users!

_è¯‘ï¼šPinia ä» 2019 å¹´ 11 æœˆå·¦å³å¼€å§‹å°è¯•é‡æ–°è®¾è®¡ Vue store çš„åˆæˆ APIã€‚ä»é‚£æ—¶èµ·ï¼Œæœ€åˆçš„åŸåˆ™ä»ç„¶æ˜¯ä¸€æ ·çš„ï¼Œä½† Pinia åŒæ—¶é€‚ç”¨äº Vue 2 å’Œ Vue 3ï¼Œä¸éœ€è¦æ‚¨ä½¿ç”¨åˆæˆ APIã€‚é™¤äº†å®‰è£…å’Œ SSR ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ª API éƒ½æ˜¯ç›¸åŒçš„ï¼Œè¿™äº›æ–‡æ¡£é’ˆå¯¹ Vue 3ï¼Œå¹¶åœ¨å¿…è¦æ—¶æä¾›æœ‰å…³ Vue 2 çš„è¯´æ˜ï¼Œä»¥ä¾¿ Vue 2 å’Œ Vue 3 ç”¨æˆ·å¯ä»¥é˜…è¯»ï¼_

**Why should I use Pinia?**

`ä¸ºä»€ä¹ˆæˆ‘åº”è¯¥ä½¿ç”¨Piniaï¼Ÿ`

Pinia is a store library for Vue, it allows you to share a state across components/pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple `export const state = reactive({})`. This is true for single page applications but **exposes your application to [security vulnerabilities](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)** if it is server side rendered. But even in small single page applications, you get a lot from using Pinia:

_è¯‘ï¼šPinia æ˜¯ä¸€ä¸ª Vue çš„å­˜å‚¨åº“ï¼Œå®ƒå…è®¸ä½ åœ¨ç»„ä»¶/é¡µé¢ä¹‹é—´å…±äº«çŠ¶æ€ã€‚å¦‚æœä½ ç†Ÿæ‚‰åˆæˆ APIï¼Œä½ å¯èƒ½ä¼šè®¤ä¸ºä½ å¯ä»¥é€šè¿‡ç®€å•çš„`export const state = reactive({})`å…±äº«å…¨å±€çŠ¶æ€ã€‚è¿™æ˜¯å¯¹äºå•é¡µåº”ç”¨çš„çœŸå®æƒ…å†µï¼Œä½†_ **å¦‚æœå®ƒæ˜¯æœåŠ¡å™¨ç«¯æ¸²æŸ“ï¼Œå®ƒä¼šæš´éœ²æ‚¨çš„åº”ç”¨ç¨‹åºåˆ°[å®‰å…¨æ¼æ´](https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution)**ã€‚_ä½†å³ä½¿æ˜¯å°çš„å•é¡µåº”ç”¨ï¼Œä½¿ç”¨ Pinia ä¹Ÿå¾ˆå¤šï¼š_

- Devtools support _å¼€å‘å·¥å…·æ”¯æŒ_
  - A timeline to track actions, mutations _è¿½è¸ªè¡ŒåŠ¨ã€çªå˜çš„æ—¶é—´è¡¨_
  - Stores appear in components where they are used _å­˜å‚¨å‡ºç°åœ¨ä½¿ç”¨å®ƒä»¬çš„ç»„ä»¶ä¸­_
  - Time travel and easier debugging _æ—¶é—´æ—…è¡Œå’Œæ›´å®¹æ˜“è°ƒè¯•_
- Hot module replacement _å¿«é€Ÿæ›´æ–°_
  - Modify your stores without reloading your page _åœ¨ä¸é‡æ–°åŠ è½½é¡µé¢çš„æƒ…å†µä¸‹ä¿®æ”¹ä½ çš„å­˜å‚¨_
  - Keep any existing state while developing _åœ¨å¼€å‘æ—¶ä¿æŒä»»ä½•ç°æœ‰çŠ¶æ€_
- Plugins: extend Pinia features with plugins _åŠŸèƒ½æ‰©å±•ï¼šä½¿ç”¨æ’ä»¶æ‰©å±• Pinia åŠŸèƒ½_
- Proper TypeScript support or **autocompletion** for JS users \*å¯¹äº JS ç”¨æˆ·çš„æ­£ç¡®çš„ TypeScript æ”¯æŒæˆ–**è‡ªåŠ¨å®Œæˆ\***
- Server Side Rendering Support _å®Œç¾çš„æœåŠ¡å™¨ç«¯æ¸²æŸ“æ”¯æŒ_

**Basic example**

`åŸºæœ¬ç¤ºä¾‹`
This is what using pinia looks like in terms of API (make sure to check the [Getting Started](./getting-started.md) for complete instructions). You start by creating a store:
_è¯‘ï¼šè¿™æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨ pinia çœ‹èµ·æ¥åƒ APIï¼ˆè¯·æ£€æŸ¥[å¼€å§‹](./getting-started.md)ä»¥è·å–å®Œæ•´çš„æŒ‡ä»¤ï¼‰ã€‚ä½ é¦–å…ˆåˆ›å»ºä¸€ä¸ªå­˜å‚¨ï¼š_

```js
// stores/counter.js
import { defineStore } from "pinia";

export const useCounterStore = defineStore("counter", {
  state: () => {
    return { count: 0 };
  },
  // could also be defined as
  // state: () => ({ count: 0 })
  actions: {
    increment() {
      this.count++;
    },
  },
});
```

And then you _use_ it in a component:
_è¯‘ï¼šç„¶åä½ åœ¨ç»„ä»¶ä¸­`ä½¿ç”¨`å®ƒï¼š_

```js
import { useCounterStore } from "@/stores/counter";

export default {
  setup() {
    const counter = useCounterStore();

    counter.count++;
    // with autocompletion âœ¨
    counter.$patch({ count: counter.count + 1 });
    // or using an action instead
    counter.increment();
  },
};
```

You can even use a function (similar to a component `setup()`) to define a Store for more advanced use cases:
_è¯‘ï¼šä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å‡½æ•°ï¼ˆä¸ç»„ä»¶`setup()`ç›¸ä¼¼ï¼‰æ¥å®šä¹‰ä¸€ä¸ªå­˜å‚¨ä»¥æ›´é«˜çº§çš„ä½¿ç”¨æƒ…å†µï¼š_

```js
export const useCounterStore = defineStore("counter", () => {
  const count = ref(0);
  function increment() {
    count.value++;
  }

  return { count, increment };
});
```

If you are still not into `setup()` and Composition API, don't worry, Pinia also support a similar set of [_map helpers_ like Vuex](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper). You define stores the same way but then use `mapStores()`, `mapState()`, or `mapActions()`:
_è¯‘ï¼šå¦‚æœä½ è¿˜ä¸æ˜¯`setup()`å’Œ Composition API çš„ç†Ÿæ‚‰ï¼Œä¸ç”¨æ‹…å¿ƒï¼ŒPinia ä¹Ÿæ”¯æŒ[Vuex çš„*map helpers*ï¼ˆå¦‚ Vuexï¼‰](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper)ã€‚ä½ å®šä¹‰å­˜å‚¨çš„æ–¹å¼ç›¸åŒï¼Œç„¶åä½¿ç”¨`mapStores()`, `mapState()`,æˆ–`mapActions()`ï¼š_

```js
const useCounterStore = defineStore("counter", {
  state: () => ({ count: 0 }),
  getters: {
    double: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++;
    },
  },
});

const useUserStore = defineStore("user", {
  // ...
});

export default {
  computed: {
    // other computed properties
    // ...
    // gives access to this.counterStore and this.userStore
    ...mapStores(useCounterStore, useUserStore),
    // gives read access to this.count and this.double
    ...mapState(useCounterStore, ["count", "double"]),
  },
  methods: {
    // gives access to this.increment()
    ...mapActions(useCounterStore, ["increment"]),
  },
};
```

You will find more information about each _map helper_ in the core concepts.
_è¯‘ï¼šä½ å°†æ‰¾åˆ°æ›´å¤šå…³äºæ¯ä¸ª*map helper*çš„ä¿¡æ¯ã€‚_

**Why _Pinia_**

_ä¸ºä»€ä¹ˆå« Pinia_

Pinia (pronounced `/piËnjÊŒ/`, like "peenya" in English) is the closest word to _piÃ±a_ (_pineapple_ in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It's also a delicious tropical fruit indigenous to South America.

_Pinia å‘éŸ³ `/piËnjÊŒ/`ï¼Œç±»ä¼¼äºè‹±è¯­ä¸­çš„â€œæŸ æª¬â€ï¼Œå®ƒæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„åŒ…åã€‚ä¸€ä¸ªæŸ æª¬æ˜¯å®é™…ä¸Šæ˜¯ä¸€ç»„å•ä¸ªèŠ±æœµç»“åˆåœ¨ä¸€èµ·ï¼Œä»¥åˆ›å»ºå¤šä¸ªæ°´æœã€‚ä¸å­˜å‚¨ç›¸ä¼¼ï¼Œæ¯ä¸€ä¸ªéƒ½æ˜¯å•ç‹¬å‡ºç”Ÿçš„ï¼Œä½†æ˜¯ä»–ä»¬éƒ½æ˜¯æœ€ç»ˆè¿æ¥åœ¨ä¸€èµ·çš„ã€‚å®ƒä¹Ÿæ˜¯ä¸€ä¸ªåœ¨å—ç¾æ´²çš„ç¾é£Ÿã€‚_

**A more realistic example**

_è¯‘ï¼šæ›´çœŸå®çš„ä¾‹å­_
Here is a more complete example of the API you will be using with Pinia **with types even in JavaScript**. For some people, this might be enough to get started without reading further but we still recommend checking the rest of the documentation or even skipping this example and coming back once you have read about all of the _Core Concepts_.
_è¯‘ï¼šè¿™æ˜¯ä¸€ä¸ªæ›´å®Œæ•´çš„ä¾‹å­ï¼Œä½ å°†ä½¿ç”¨ Pinia**ç±»å‹åœ¨ JavaScript**ã€‚å¯¹äºä¸€äº›äººï¼Œè¿™å¯èƒ½æ˜¯è¶³å¤Ÿå¼€å§‹è€Œä¸éœ€è¦é˜…è¯»æ›´å¤šï¼Œä½†æˆ‘ä»¬ä»ç„¶å»ºè®®æ£€æŸ¥å…¶ä½™çš„æ–‡æ¡£æˆ–è·³è¿‡è¿™ä¸ªä¾‹å­ï¼Œç„¶åå›æ¥ä¸€æ¬¡ä½ å·²ç»é˜…è¯»äº†æ‰€æœ‰çš„**æ ¸å¿ƒæ¦‚å¿µ**ã€‚_

```js
import { defineStore } from "pinia";

export const todos = defineStore("todos", {
  state: () => ({
    /** @type {{ text: string, id: number, isFinished: boolean }[]} */
    todos: [],
    /** @type {'all' | 'finished' | 'unfinished'} */
    filter: "all",
    // type will be automatically inferred to number
    // ç±»å‹å°†è‡ªåŠ¨æ¨æ–­ä¸ºnumber
    nextId: 0,
  }),
  getters: {
    finishedTodos(state) {
      // autocompletion! âœ¨
      // è‡ªåŠ¨å®Œæˆ
      return state.todos.filter((todo) => todo.isFinished);
    },
    unfinishedTodos(state) {
      return state.todos.filter((todo) => !todo.isFinished);
    },
    /**
     * @returns {{ text: string, id: number, isFinished: boolean }[]}
     */
    filteredTodos(state) {
      if (this.filter === "finished") {
        // call other getters with autocompletion âœ¨
        // è°ƒç”¨å…¶ä»–gettersè‡ªåŠ¨å®Œæˆ
        return this.finishedTodos;
      } else if (this.filter === "unfinished") {
        return this.unfinishedTodos;
      }
      return this.todos;
    },
  },
  actions: {
    // any amount of arguments, return a promise or not
    // ä»»æ„æ•°é‡çš„å‚æ•°ï¼Œè¿”å›ä¸€ä¸ªpromiseæˆ–ä¸
    addTodo(text) {
      // you can directly mutate the state
      // ä½ å¯ä»¥ç›´æ¥ä¿®æ”¹çŠ¶æ€
      this.todos.push({ text, id: this.nextId++, isFinished: false });
    },
  },
});
```

**Comparison with Vuex**

_è¯‘ï¼šä¸ Vuex æ¯”è¾ƒ_

Pinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.
_è¯‘ï¼šPinia å¼€å§‹äº†ä¸€ä¸ªæ¢ç´¢ Vuex çš„ä¸‹ä¸€ä¸ªè¿­ä»£ï¼Œå¹¶ä¸”å°†å¤§é‡çš„æƒ³æ³•ä» Vuex 5 çš„æ ¸å¿ƒå›¢é˜Ÿè®¨è®ºä¸­æå–ã€‚æœ€ç»ˆï¼Œæˆ‘ä»¬è®¤ä¸º Pinia å·²ç»å®ç°äº†å¤§éƒ¨åˆ†æˆ‘ä»¬æƒ³è¦çš„ Vuex 5ï¼Œå¹¶ä¸”å†³å®šæ”¹å˜å®ƒçš„æ¨èã€‚_
Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.
_è¯‘ï¼šä¸ Vuex æ¯”è¾ƒï¼ŒPinia æä¾›äº†æ›´ç®€å•çš„ APIï¼Œæä¾›äº†ç»„åˆ API çš„ APIï¼Œå¹¶ä¸”åœ¨ä½¿ç”¨ TypeScript æ—¶æœ‰å®ä½“ç±»å‹æ”¯æŒã€‚_

**RFCs**

_è¯‘ï¼šRFCs_

> RFCs æ¶µç›–äº† Vue çš„æœ€åŸºæœ¬çš„å››ä¸ªéƒ¨åˆ†ï¼Œæˆªè‡³ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»æœ‰ 38 ä¸ª PR æäº¤ï¼ˆ26 ä¸ªä»åœ¨è®¨è®ºä¸­ï¼‰ï¼Œè¿™äº›æè®®ä¸­æ—¢æœ‰ Vue ä½œè€…è‡ªå·±çš„æè®®ï¼Œä¹Ÿæœ‰å¼€å‘è€…çš„æè®®ã€‚
>
> - Vue core
> - Vue Router
> - Vuex
> - Vue CLI

Initially Pinia didn't go through any RFC. I tested out ideas based on my experience developing applications, reading other people's code, working for clients who use Pinia, and answering questions on Discord.
This allowed me to provide a solution that works and is adapted to a variety of cases and application sizes. I used to publish often and made the library evolve while keeping its core API the same.
_è¯‘ï¼šåˆå§‹ Pinia æ²¡æœ‰é€šè¿‡ä»»ä½• RFCã€‚æˆ‘æµ‹è¯•äº†åŸºäºæˆ‘çš„ç»éªŒå¼€å‘åº”ç”¨ç¨‹åºï¼Œé˜…è¯»å…¶ä»–äººçš„ä»£ç ï¼Œä¸ºä½¿ç”¨ Pinia çš„å®¢æˆ·å·¥ä½œï¼Œå¹¶åœ¨ Discord ä¸Šå›ç­”é—®é¢˜ã€‚è¿™è®©æˆ‘æä¾›äº†ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼Œå®ƒå·¥ä½œå¹¶é€‚åˆå„ç§æƒ…å†µå’Œåº”ç”¨ç¨‹åºå¤§å°ã€‚æˆ‘ç»å¸¸å‘å¸ƒï¼Œå¹¶åœ¨ä¿æŒæ ¸å¿ƒ API ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œä½¿åº“å‘å±•ã€‚_
Now that Pinia has become the default state management solution, it is subject to the same RFC process as other core libraries in the Vue ecosystem and its API has entered a stable state.
_è¯‘ï¼šç°åœ¨ï¼ŒPinia å·²ç»æˆä¸º Vue çš„æ ¸å¿ƒçŠ¶æ€ç®¡ç†è§£å†³æ–¹æ¡ˆï¼Œå®ƒä¸ Vue ç¤¾åŒºä¸­å…¶ä»–æ ¸å¿ƒåº“çš„ RFC è¿›è¡Œäº†ç›¸åŒçš„å¤„ç†ï¼Œå¹¶ä¸”å®ƒçš„ API å·²ç»è¿›å…¥äº†ä¸€ä¸ªç¨³å®šçŠ¶æ€ã€‚_

**Comparison with Vuex 3.x/4.x**

_è¯‘ï¼šä¸ Vuex 3.x/4.x æ¯”è¾ƒ_

> Vuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3
> Vuex 3.x æ˜¯ Vuex 2 çš„ Vuexï¼Œè€Œ Vuex 4.x æ˜¯ Vue 3 çš„ Vuex
> Pinia API is very different from Vuex â‰¤4, namely:
> _è¯‘ï¼šPinia API ä¸ Vuex 3.x/4.x æ¯”è¾ƒï¼Œä¸»è¦åŒºåˆ«æ˜¯ï¼š_

- _mutations_ no longer exist. They were very often perceived as **_extremely_ verbose**. They initially brought devtools integration but that is no longer an issue.
  `- mutations ä¸å†å­˜åœ¨ã€‚å®ƒä»¬åˆå§‹ä¸ŠæŠ›äº†å¼€å‘å·¥å…·é›†æˆï¼Œä½†è¿™ä¸å†æ˜¯é—®é¢˜ã€‚`
- No need to create custom complex wrappers to support TypeScript, everything is typed and the API is designed in a way to leverage TS type inference as much as possible.
  `- æ²¡æœ‰éœ€è¦åˆ›å»ºè‡ªå®šä¹‰å¤æ‚çš„åŒ…è£…æ¥æ”¯æŒTypeScriptï¼Œæ‰€æœ‰çš„éƒ½æ˜¯ç±»å‹åŒ–çš„ï¼ŒAPIè®¾è®¡äº†ä¸€ä¸ªè®©ä½ æœ€å¤§é™åº¦åœ°åˆ©ç”¨TSç±»å‹æ¨æ–­çš„æ–¹å¼ã€‚`
- No more magic strings to inject, import the functions, call them, enjoy autocompletion!
  `- æ²¡æœ‰æ›´å¤šçš„é­”æ³•å­—ç¬¦ä¸²æ³¨å…¥ï¼Œå¯¼å…¥å‡½æ•°ï¼Œè°ƒç”¨å®ƒä»¬ï¼Œäº«å—è‡ªåŠ¨å®Œæˆï¼`
- No need to dynamically add stores, they are all dynamic by default and you won't even notice. Note you can still manually use a store to register it whenever you want but because it is automatic you don't need to worry about it.
  `- æ²¡æœ‰éœ€è¦åŠ¨æ€æ·»åŠ å­˜å‚¨ï¼Œå®ƒä»¬éƒ½æ˜¯é»˜è®¤çš„åŠ¨æ€çš„ï¼Œä½ ä¹Ÿä¸ä¼šå‘ç°ã€‚è¯·æ³¨æ„ï¼Œä½ ä»ç„¶å¯ä»¥æ‰‹åŠ¨ä½¿ç”¨å­˜å‚¨æ¥æ³¨å†Œå®ƒï¼Œä½†æ˜¯å› ä¸ºå®ƒæ˜¯è‡ªåŠ¨çš„ï¼Œä½ ä¸éœ€è¦æ‹…å¿ƒå®ƒã€‚`
- No more nested structuring of _modules_. You can still nest stores implicitly by importing and _using_ a store inside another but Pinia offers a flat structuring by design while still enabling ways of cross composition among stores. **You can even have circular dependencies of stores**.
  `- æ²¡æœ‰æ›´å¤šçš„åµŒå¥—ç»“æ„çš„_æ¨¡å—_ã€‚ä½ ä»ç„¶å¯ä»¥åµŒå¥—å­˜å‚¨é€šè¿‡å¯¼å…¥å¹¶ä½¿ç”¨å­˜å‚¨åœ¨å¦ä¸€ä¸ªå­˜å‚¨ä¸­ï¼Œä½†Piniaæä¾›äº†ä¸€ä¸ªå¹³é¢çš„ç»“æ„ï¼Œè€Œä¸”è¿˜å…è®¸åœ¨å­˜å‚¨ä¹‹é—´è·¨è¶Šç»„åˆã€‚**ä½ è¿˜å¯ä»¥æœ‰åœ†å½¢ä¾èµ–çš„å­˜å‚¨**ã€‚`
- No _namespaced modules_. Given the flat architecture of stores, "namespacing" stores is inherent to how they are defined and you could say all stores are namespaced.
  `- æ²¡æœ‰_å‘½åç©ºé—´æ¨¡å—_ã€‚ç»™å®šå­˜å‚¨çš„å¹³é¢å»ºæ„ï¼Œâ€œå‘½åç©ºé—´â€å­˜å‚¨æ˜¯å› ä¸ºå®ƒä»¬å®šä¹‰çš„æ–¹å¼è€Œå…·æœ‰çš„ï¼Œä½ å¯ä»¥è¯´æ‰€æœ‰çš„å­˜å‚¨éƒ½æ˜¯å‘½åç©ºé—´ã€‚`
  For more detailed instructions on how to convert an existing Vuex â‰¤4 project to use Pinia, see the [Migration from Vuex Guide](./cookbook/migration-vuex.md).
  _è¯‘ï¼šä¸ºäº†æ›´åŠ è¯¦ç»†çš„æŒ‡å¯¼å¦‚ä½•å°†ç°æœ‰çš„ Vuex â‰¤4 é¡¹ç›®è½¬æ¢ä¸ºä½¿ç”¨ Piniaï¼Œè¯·å‚é˜…[Migration from Vuex Guide](./cookbook/migration-vuex.md)ã€‚_

## [èµ·æ­¥](https://pinia.vuejs.org/getting-started.html#installation)

### Installation

Install `pinia` with your favorite package manager:
_è¯‘ï¼šä½¿ç”¨ä½ å–œæ¬¢çš„åŒ…ç®¡ç†å™¨å®‰è£… `pinia` ï¼š_

```bash
yarn add pinia
# or with npm
npm install pinia
```

:::tip
If your app is using Vue 2, you also need to install the composition api: `@vue/composition-api`. If you are using Nuxt, you should follow [these instructions](https://pinia.vuejs.org/ssr/nuxt.html).
_è¯‘ï¼šå¦‚æœä½ çš„åº”ç”¨ä½¿ç”¨ Vue 2ï¼Œä½ è¿˜éœ€è¦å®‰è£…ç»„åˆ apiï¼š`@vue/composition-api`ã€‚å¦‚æœä½ ä½¿ç”¨ Nuxtï¼Œä½ åº”è¯¥éµå¾ª[è¿™äº›æŒ‡å¯¼](https://pinia.vuejs.org/ssr/nuxt.html)ã€‚_
:::

If you are using the Vue CLI, you can instead give this [**unofficial plugin**](https://github.com/wobsoriano/vue-cli-plugin-pinia) a try.
\_è¯‘ï¼šå¦‚æœä½ ä½¿ç”¨ Vue CLIï¼Œä½ å¯ä»¥è¯•è¯•è¿™ä¸ª [**éå®˜æ–¹æ’ä»¶**](

Create a pinia (the root store) and pass it to the app:
_è¯‘ï¼šåˆ›å»ºä¸€ä¸ª pinia ï¼ˆæ ¹å­˜å‚¨ï¼‰å¹¶å°†å…¶ä¼ é€’ç»™åº”ç”¨ï¼š_

```js
import { createPinia } from "pinia";

app.use(createPinia());
```

If you are using Vue 2, you also need to install a plugin and inject the created `pinia` at the root of the app:
_è¯‘ï¼šå¦‚æœä½ ä½¿ç”¨ Vue 2ï¼Œä½ è¿˜éœ€è¦å®‰è£…ä¸€ä¸ªæ’ä»¶å¹¶å°†åˆ›å»ºçš„ `pinia` æ³¨å…¥åˆ°åº”ç”¨çš„æ ¹ä¸­ï¼š_

```js
import { createPinia, PiniaVuePlugin } from "pinia";

Vue.use(PiniaVuePlugin);
const pinia = createPinia();

new Vue({
  el: "#app",
  // other options...
  // ...
  // note the same `pinia` instance can be used across multiple Vue apps on the same page
  // æ³¨æ„ï¼ŒåŒä¸€ä¸ª `pinia` å®ä¾‹å¯ä»¥åœ¨åŒä¸€ä¸ªé¡µé¢ä¸Šçš„å¤šä¸ª Vue åº”ç”¨ä¸­ä½¿ç”¨
  pinia,
});
```

This will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn't expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).
_è¯‘ï¼šè¿™ä¹Ÿä¼šæ·»åŠ  devtools æ”¯æŒã€‚åœ¨ Vue 3 ä¸­ï¼ŒæŸäº›åŠŸèƒ½ï¼ˆä¾‹å¦‚æ—¶é—´æ—…è¡Œå’Œç¼–è¾‘ï¼‰ä»ç„¶ä¸æ”¯æŒï¼Œå› ä¸º vue-devtools ä¸æš´éœ²äº†å¿…è¦çš„ APIï¼Œä½†æ˜¯ devtools æœ‰æ›´å¤šçš„åŠŸèƒ½ï¼Œå¼€å‘è€…ä½“éªŒæ•´ä½“æ›´ä¼˜ã€‚åœ¨ Vue 2 ä¸­ï¼ŒPinia ä½¿ç”¨ç°æœ‰çš„ Vuex æ¥å£ï¼ˆå› æ­¤ä¸èƒ½ä¸å®ƒä¸€èµ·ä½¿ç”¨ï¼‰ã€‚_

### What is a Store?

A Store (like Pinia) is an entity holding state and business logic that isn't bound to your Component tree. In other words, **it hosts global state**. It's a bit like a component that is always there and that everybody can read off and write to. It has **three concepts**, the [state](./core-concepts/state.md), [getters](./core-concepts/getters.md) and [actions](./core-concepts/actions.md) and it's safe to assume these concepts are the equivalent of `data`, `computed` and `methods` in components.
_è¯‘ï¼šä¸€ä¸ªå­˜å‚¨ï¼ˆåƒ Piniaï¼‰æ˜¯ä¸€ä¸ªæŒæœ‰çŠ¶æ€å’Œä¸šåŠ¡é€»è¾‘çš„å®ä½“ï¼Œå®ƒä¸æ˜¯ç»‘å®šåˆ°ä½ çš„ç»„ä»¶æ ‘ä¸Šçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ**å®ƒæŒæœ‰å…¨å±€çŠ¶æ€**ã€‚å®ƒæ˜¯ä¸€ä¸ªæ€»æ˜¯å­˜åœ¨çš„ç»„ä»¶ï¼Œæ¯ä¸ªäººéƒ½å¯ä»¥è¯»å–å¹¶å†™å…¥ã€‚å®ƒæœ‰ **ä¸‰ä¸ªæ¦‚å¿µ**ï¼Œ[state](./core-concepts/state.md)ï¼Œ[getters](./core-concepts/getters.md) å’Œ [actions](./core-concepts/actions.md)ï¼Œå¹¶ä¸”æˆ‘ä»¬å‡è®¾è¿™ä¸‰ä¸ªæ¦‚å¿µæ˜¯ç»„ä»¶çš„ `data`ï¼Œ`computed` å’Œ `methods` çš„ç­‰ä»·ã€‚_

### When should I use a Store

A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.
_è¯‘ï¼šä¸€ä¸ªå­˜å‚¨åº”è¯¥åŒ…å«å¯ä»¥åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¸­è®¿é—®çš„æ•°æ®ã€‚è¿™åŒ…æ‹¬åœ¨å¤šä¸ªåœ°æ–¹ä½¿ç”¨çš„æ•°æ®ï¼Œä¾‹å¦‚åœ¨å¯¼èˆªæ ä¸­æ˜¾ç¤ºçš„ç”¨æˆ·ä¿¡æ¯ï¼Œä»¥åŠéœ€è¦åœ¨é¡µé¢ä¸­ä¿ç•™çš„æ•°æ®ï¼Œä¾‹å¦‚ä¸€ä¸ªå¤æ‚çš„å¤šæ­¥éª¤è¡¨å•ã€‚_
On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.
_è¯‘ï¼šå¦ä¸€æ–¹é¢ï¼Œä½ åº”è¯¥é¿å…åœ¨å­˜å‚¨ä¸­åŒ…å«åœ¨ç»„ä»¶ä¸­å­˜å‚¨çš„æœ¬åœ°æ•°æ®ï¼Œä¾‹å¦‚é¡µé¢ä¸­çš„ä¸€ä¸ªå…ƒç´ çš„å¯è§æ€§ã€‚_
Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.
_è¯‘ï¼šä¸æ˜¯æ‰€æœ‰åº”ç”¨éƒ½éœ€è¦è®¿é—®å…¨å±€çŠ¶æ€ï¼Œä½†å¦‚æœä½ çš„åº”ç”¨éœ€è¦ä¸€ä¸ªï¼ŒPinia å°†ä½¿ä½ çš„ç”Ÿæ´»æ›´åŠ æ–¹ä¾¿ã€‚_

## æ ¸å¿ƒæ¦‚å¿µ

### Store

**Defining a Store**

<VueSchoolLink
  href="https://vueschool.io/lessons/define-your-first-pinia-store"
  title="Learn how to define and use stores in Pinia"
/>

Before diving into core concepts, we need to know that a store is defined using `defineStore()` and that it requires a **unique** name, passed as the first argument:
_è¯‘ï¼šåœ¨æ·±å…¥æ ¸å¿ƒæ¦‚å¿µä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ä¸€ä¸ªå­˜å‚¨ç”± `defineStore()` å®šä¹‰å¹¶ä¸”éœ€è¦ä¸€ä¸ª **å”¯ä¸€çš„** åç§°ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼š_

```js
import { defineStore } from "pinia";

// useStore could be anything like useUser, useCart
// the first argument is a unique id of the store across your application
export const useStore = defineStore("main", {
  // other options...
});
```

This _name_, also referred as _id_, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function _use..._ is a convention across composables to make its usage idiomatic.
_è¯‘ï¼šè¿™ä¸ªåç§°ï¼Œä¹Ÿç§°ä¸º _id_ï¼Œæ˜¯å¿…éœ€çš„å¹¶ä¸”ç”¨äºè¿æ¥å­˜å‚¨åˆ° devtoolsã€‚å‘½åè¿”å›çš„å‡½æ•° _use..._ æ˜¯ä¸€ä¸ªç»„åˆä½¿ç”¨çš„æƒ¯ä¾‹ï¼Œä½¿ç”¨å®ƒçš„ç”¨æ³•ç®€å•æ˜“æ‡‚ã€‚_
**Using the store**

We are _defining_ a store because the store won't be created until `useStore()` is called inside of `setup()`:
_è¯‘ï¼šæˆ‘ä»¬æ­£åœ¨å®šä¹‰ä¸€ä¸ªå­˜å‚¨ï¼Œå› ä¸ºåªæœ‰åœ¨`setupï¼ˆï¼‰`å†…éƒ¨è°ƒç”¨`useStoreï¼ˆï¼‰`æ‰èƒ½åˆ›å»ºè¯¥å­˜å‚¨_

```js
import { useStore } from "@/stores/counter";

export default {
  setup() {
    const store = useStore();

    return {
      // you can return the whole store instance to use it in the template
      // ä½ å¯ä»¥åœ¨æ¨¡æ¿ä¸­è¿”å›æ•´ä¸ªå­˜å‚¨å®ä¾‹æ¥ä½¿ç”¨å®ƒ
      store,
    };
  },
};
```

You can define as many stores as you want and **you should define each store in a different file** to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).
_è¯‘ ï¼šä½ å¯ä»¥å®šä¹‰å¤šä¸ªå­˜å‚¨ï¼Œä½ åº”è¯¥åœ¨ä¸åŒçš„æ–‡ä»¶ä¸­å®šä¹‰æ¯ä¸ªå­˜å‚¨æ¥è·å¾— pinia çš„æœ€å¤§æ•ˆç”¨ï¼ˆä¾‹å¦‚è‡ªåŠ¨å…è®¸ä½ çš„ bundle åˆ†å‰²å’Œ TypeScript æ¨æ–­ï¼‰ã€‚_
If you are not using `setup` components yet, [you can still use Pinia with _map helpers_](https://pinia.vuejs.org/cookbook/options-api.html).
_è¯‘ï¼šå¦‚æœä½ è¿˜æ²¡æœ‰ä½¿ç”¨ `setup` ç»„ä»¶ï¼Œä½ ä»ç„¶å¯ä»¥ä½¿ç”¨ Pinia ä¸ [map åŠ©æ‰‹]ï¼ˆhttps://pinia.vuejs.org/cookbook/options-api.htmlï¼‰ã€‚_
Once the store is instantiated, you can access any property defined in `state`, `getters`, and `actions` directly on the store. We will see these in detail in the next pages but autocompletion will help you.
_è¯‘ï¼šä¸€æ—¦å­˜å‚¨è¢«å®ä¾‹åŒ–ï¼Œä½ å¯ä»¥ç›´æ¥åœ¨å­˜å‚¨ä¸Šè®¿é—® `state`ï¼Œ`getters` å’Œ `actions` ä¸­å®šä¹‰çš„å±æ€§ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€é¡µä¸­è¯¦ç»†è®²è§£ï¼Œä½†æ˜¯è‡ªåŠ¨è¡¥å…¨å°†å¸®åŠ©ä½ ã€‚_
Note that `store` is an object wrapped with `reactive`, meaning there is no need to write `.value` after getters but, like `props` in `setup`, **we cannot destructure it**:
_è¯‘ï¼šè¯·æ³¨æ„ï¼Œå­˜å‚¨æ˜¯ä¸€ä¸ª `reactive` åŒ…è£…çš„å¯¹è±¡ï¼Œå› æ­¤ä¸éœ€è¦å†™ `.value` åé¢çš„ gettersï¼Œä½†æ˜¯ï¼Œåƒ `setup` ä¸­çš„ `props`ï¼Œæˆ‘ä»¬ä¸èƒ½è§£æ„å®ƒ_

```js
export default defineComponent({
  setup() {
    const store = useStore();
    // âŒ This won't work because it breaks reactivity it's the same as destructuring from `props`
    // è¿™ä¸ä¼šå·¥ä½œï¼Œå› ä¸ºå®ƒä¼šç ´åå¯è§‚å¯Ÿæ€§ï¼Œå®ƒæ˜¯ç›¸åŒçš„ä¸º `props` æ„é€ çš„
    const { name, doubleCount } = store;

    name; // "eduardo"
    doubleCount; // 2

    return {
      // will always be "eduardo"
      // å°†å§‹ç»ˆæ˜¯ "eduardo"
      name,
      // will always be 2
      // å°†å§‹ç»ˆæ˜¯ 2
      doubleCount,
      // this one will be reactive
      // è¿™ä¸ªå°†æ˜¯å¯è§‚å¯Ÿçš„
      doubleValue: computed(() => store.doubleCount),
    };
  },
});
```

In order to extract properties from the store while keeping its reactivity, you need to use `storeToRefs()`. It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:
_è¯‘ï¼šä¸ºäº†ä»å­˜å‚¨ä¸­æå–å±æ€§è€Œä¿æŒå…¶å¯è§‚å¯Ÿæ€§ï¼Œä½ éœ€è¦ä½¿ç”¨ `storeToRefs()`ã€‚å®ƒä¼šåˆ›å»ºæ¯ä¸ªå¯è§‚å¯Ÿå±æ€§çš„ refã€‚è¿™å¯¹äºåªä½¿ç”¨å­˜å‚¨ä¸­çš„çŠ¶æ€ä½†ä¸è°ƒç”¨ä»»ä½•è¡Œä¸ºæ—¶éå¸¸æœ‰ç”¨ã€‚è¯·æ³¨æ„ï¼Œä½ å¯ä»¥ç›´æ¥ä»å­˜å‚¨ä¸­è§£æ„ actionsï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯ç»‘å®šåˆ°å­˜å‚¨æœ¬èº«çš„ã€‚_

```js
import { storeToRefs } from "pinia";

export default defineComponent({
  setup() {
    const store = useStore();
    // `name` and `doubleCount` are reactive refs
    // This will also create refs for properties added by plugins
    // but skip any action or non reactive (non ref/reactive) property
    const { name, doubleCount } = storeToRefs(store);
    // the increment action can be just extracted
    const { increment } = store;

    return {
      name,
      doubleCount,
      increment,
    };
  },
});
```

### State

<VueSchoolLink
  href="https://vueschool.io/lessons/access-state-from-a-pinia-store"
  title="Learn all about state in Pinia"
/>

The state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.
_å¤§å¤šæ•°æ—¶å€™ï¼Œstateæ˜¯ä½ storeçš„ä¸­å¿ƒã€‚äººä»¬é€šå¸¸ä»å®šä¹‰ä»£è¡¨å…¶åº”ç”¨ç¨‹åºçš„çŠ¶æ€å¼€å§‹ã€‚åœ¨Piniaä¸­ï¼ŒçŠ¶æ€å®šä¹‰ä¸ºè¿”å›åˆå§‹çŠ¶æ€çš„å‡½æ•°ã€‚è¿™å…è®¸Piniaåœ¨æœåŠ¡å™¨ç«¯å’Œå®¢æˆ·ç«¯éƒ½å·¥ä½œã€‚_
```js
import { defineStore } from "pinia";

const useStore = defineStore("storeId", {
  // arrow function recommended for full type inference
  state: () => {
    return {
      // all these properties will have their type inferred automatically
      counter: 0,
      name: "Eduardo",
      isAdmin: true,
    };
  },
});
```

:::tip
If you are using Vue 2, the data you create in `state` follows the same rules as the `data` in a Vue instance, ie the state object must be plain and you need to call `Vue.set()` when **adding new** properties to it. **See also: [Vue#data](https://v2.vuejs.org/v2/api/#data)**.
:::

**Accessing the `state`**

By default, you can directly read and write to the state by accessing it through the `store` instance:

```js
const store = useStore();

store.counter++;
```

**Resetting the state**

You can _reset_ the state to its initial value by calling the `$reset()` method on the store:

```js
const store = useStore();

store.$reset();
```

**Usage with the Options API**

<VueSchoolLink
  href="https://vueschool.io/lessons/access-pinia-state-in-the-options-api"
  title="Access Pinia State via the Options API"
/>

For the following examples, you can assume the following store was created:

```js
// Example File Path:
// ./src/stores/counterStore.js

import { defineStore } from "pinia";

const useCounterStore = defineStore("counterStore", {
  state: () => ({
    counter: 0,
  }),
});
```

If you are not using the Composition API, and you are using `computed`, `methods`, ..., you can use the `mapState()` helper to map state properties as readonly computed properties:

```js
import { mapState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component
    // same as reading from store.counter
    ...mapState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapState(useCounterStore, {
      myOwnName: 'counter',
      // you can also write a function that gets access to the store
      double: store => store.counter * 2,
      // it can have access to `this` but it won't be typed correctly...
      magicValue(store) {
        return store.someGetter + this.counter + this.double
      },
    }),
  },
}
```

**Modifiable state**

If you want to be able to write to these state properties (e.g. if you have a form), you can use `mapWritableState()` instead. Note you cannot pass a function like with `mapState()`:

```js
import { mapWritableState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component and allows setting it
    // this.counter++
    // same as reading from store.counter
    ...mapWritableState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapWritableState(useCounterStore, {
      myOwnName: 'counter',
    }),
  },
}
```

:::tip
You don't need `mapWritableState()` for collections like arrays unless you are replacing the whole array with `cartItems = []`, `mapState()` still allows you to call methods on your collections.
:::

**Mutating the state**

<!-- TODO: disable this with `strictMode` -->

Apart from directly mutating the store with `store.counter++`, you can also call the `$patch` method. It allows you to apply multiple changes at the same time with a partial `state` object:

```js
store.$patch({
  counter: store.counter + 1,
  name: "Abalam",
});
```

However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the `$patch` method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:

```js
cartStore.$patch((state) => {
  state.items.push({ name: "shoes", quantity: 1 });
  state.hasChanged = true;
});
```

<!-- TODO: disable this with `strictMode`, `{ noDirectPatch: true }` -->

The main difference here is that `$patch()` allows you to group multiple changes into one single entry in the devtools. Note **both, direct changes to `state` and `$patch()` appear in the devtools** and can be time travelled (not yet in Vue 3).

**Replacing the `state`**

You can replace the whole state of a store by setting its `$state` property to a new object:

```js
store.$state = { counter: 666, name: "Paimon" };
```

You can also replace the whole state of your application by changing the `state` of the `pinia` instance. This is used during [SSR for hydration](../ssr/#state-hydration).

```js
pinia.state.value = {};
```

**Subscribing to the state**

You can watch the state and its changes through the `$subscribe()` method of a store, similar to Vuex's [subscribe method](https://vuex.vuejs.org/api/#subscribe). The advantage of using `$subscribe()` over a regular `watch()` is that _subscriptions_ will trigger only once after _patches_ (e.g. when using the function version from above).

```js
cartStore.$subscribe((mutation, state) => {
  // import { MutationType } from 'pinia'
  mutation.type; // 'direct' | 'patch object' | 'patch function'
  // same as cartStore.$id
  mutation.storeId; // 'cart'
  // only available with mutation.type === 'patch object'
  mutation.payload; // patch object passed to cartStore.$patch()

  // persist the whole state to the local storage whenever it changes
  localStorage.setItem("cart", JSON.stringify(state));
});
```

By default, _state subscriptions_ are bound to the component where they are added (if the store is inside a component's `setup()`). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass `{ detached: true }` as the second argument to _detach_ the _state subscription_ from the current component:

```js
export default {
  setup() {
    const someStore = useSomeStore();

    // this subscription will be kept after the component is unmounted
    someStore.$subscribe(callback, { detached: true });

    // ...
  },
};
```

:::tip
You can watch the whole state on the `pinia` instance:
ä½ å¯ä»¥ç›‘å¬æ•´ä¸ªpiniaå®ä¾‹çš„çŠ¶æ€ï¼Œè¿™ä¸ªçŠ¶æ€æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼ŒåŒ…å«äº†æ‰€æœ‰çš„storeçš„çŠ¶æ€ã€‚

```js
watch(
  pinia.state,
  (state) => {
    // persist the whole state to the local storage whenever it changes
    localStorage.setItem("piniaState", JSON.stringify(state));
  },
  { deep: true }
);
```

:::
