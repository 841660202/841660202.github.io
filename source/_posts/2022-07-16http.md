---
title: 前端基础-http
date: 2022-07-16 12:47:18
categories: 前端基础
tags: [前端基础, 面试]
cover:
---

## HTTP ⽅法

`HTTP1.0` 定义了三种请求⽅法： `GET`, `POST` 和 `HEAD` ⽅法
`HTTP1.1` 新增了五种请求⽅法：`OPTIONS`, `PUT`, `DELETE`, `TRACE` 和 `CONNECT`

## HTTP ⽅法的理论作⽤

- `GET`: 通常⽤于请求服务器发送某些资源
- `HEAD`: 请求资源的头部信息, `使⽤场景`是`在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源`
- `OPTIONS`: ⽤于获取⽬的资源所⽀持的通信选项
- `POST`: 发送数据给服务器
- `PUT`: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式
- `DELETE`: ⽤于删除指定的资源
- `PATCH`: ⽤于对资源进⾏部分修改
- `CONNECT`: HTTP/1.1 协议中预留给能够将连接改为管道⽅式的代理服务器
- `TRACE`: 回显服务器收到的请求，主要⽤于测试或诊断

:::warning

理论上是这么回事，可有些研发并不一定这么操作

:::

## GET 和 POST 有什么区别？

- `数据传输⽅式不同`：GET 请求通过 URL 传输数据，⽽ POST 的数据通过请求体传输。
- `安全性不同`：POST 的数据因为在请求主体内，所以有⼀定的安全性保证，⽽ GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息。
- `数据类型不同`：GET 只允许 ASCII 字符，⽽ POST ⽆限制 GET ⽆害： 刷新、后退等浏览器操作 GET 请求是⽆害的，POST 可能重复提交表单
- `特性不同`：GET 是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的 概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽ POST 是⾮安全⾮幂等

## PUT 和 POST 有什么区别？

- PUT ⽅法是`幂等`的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽ POST ⽅法是⾮幂 等的。

- PUT 的 `URI 指向是具体单⼀资源`，⽽ POST 可以指向资源集合。

举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤

- POST https://www.jianshu.com/articles ， 这个请求的语义是，在 articles 的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。
  <br/>
  <br/>

- PUT https://www.jianshu.com/articles/1 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI 指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘华』修改成『刘德华』，提交多少次都是修改成『刘德华』

## PUT 和 PATCH 的区别？

`PUT` 和 `PATCH` 都是更新资源，⽽ `PATCH` ⽤来对已知资源进⾏局部更新。`PATCH`可以理解为打补丁
⽐如我们有⼀篇⽂章的地址 https://www.jianshu.com/articles/1 ,这篇⽂章的可以表示为:

```js
article = {
  author: "dxy",
  creationDate: "2019-6-12",
  content: "我写⽂章像刘德华",
  id: 1,
};
```

当我们要修改⽂章的作者时，我们可以直接发送

`PUT https://www.jianshu.com/articles/1` ，数据是:

```js
{
  author:'刘德华',
  creationDate: '2019-6-12',
  content: '我写⽂章像刘德华',
  id: 1
}

```

这种直接覆盖资源的修改⽅式应该⽤ put，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送

`PATCH https://www.jianshu.com/articles/1` ，这个时候只需要:

```js
{ author:'刘德华', }
```

## HTTP 的状态码有哪些？

- `101 SwitchingProtocols`，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议(`h5的websocket使用时，会出现101状态码`)

**2XX 成功**

- `200 OK`，表示从客户端发来的请求在服务器端被正确处理
- `201 Created` 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴
- `202 Accepted` 请求已接受，但是还没执⾏，不保证完成请求
- `204 No content`，表示请求成功，但响应报⽂不含实体的主体部分 客户端不做更改(`浏览器不会刷新页面，也不会导向别的页面。对客户端说好了，你别管了`)
- `206 Partial Content`，进⾏范围请求

**3XX 重定向**

- `301 moved permanently`，永久性重定向，表示资源已被分配了新的 URL
- `302 found`，临时性重定向，表示资源临时被分配了新的 URL
- `303 see other`，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源
- `304 not modified`，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况
- `307 temporary redirect`，临时重定向，和 302 含义相同

**4XX 客户端错误**

- `400 bad request`，请求报⽂存在语法错误
- `401 unauthorized`，表示发送的请求需要有通过 HTTP 认证的认证信息
- `403 forbidden`，表示对请求资源的访问被服务器拒绝
- `404 not found`，表示在服务器上没有找到请求的资源
- `408 Request timeout`, 客户端请求超时
- `409 Confict`, 请求的资源可能引起冲突

**5XX 服务器错误**

- `500 internal sever error`，表示服务器端在执⾏请求时发⽣了错误
- `501 Not Implemented` 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务 器不⽀持的某个⽅法
- `502 BadGateway` 网关错误
- `503 service unavailable`，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求
- `504 Gateway timeout` 网关超时
- `505 http version not supported` 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本

## 302,307,303 的区别？

- `302` 是 http1.0 的协议状态码，在`http1.1版本`的时候为了细化`302`状态码⼜出来了两个`303`和`307`。
- `303` 明确表示客户端应当`采⽤get⽅法获取资源`，`会把POST请求变为GET请求进⾏重定向`。
- `307` 会遵照浏览器标准， 不会从 post 变为 get。

## HTTP 的 keep-alive 是⼲什么的？

在早期的 HTTP/1.0 中，每次 http 请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，`为了减少资源消耗， 缩短响应时间，就需要重⽤连接`。
在后来的 HTTP/1.0 中以及 HTTP/1.1 中，引⼊了重⽤连接的机制，就是在 `http 请求头中`加⼊ `Connection: keep-alive` 来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。

HTTP/1.0 如果想要保持⻓连接，需要在请求头中加上 `Connection: keep-alive`。

## keep-alive 的优点：

- 较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）
- 降低拥塞控制 （TCP 连接减少了）
- 减少了后续请求的延迟（⽆需再进⾏握⼿）
- 报告错误⽆需关闭 TCP 连
- 允许请求和应答的 HTTP `管线化`(将多个 HTTP 请求（request）整批提交的技术，而在发送过程中不需先等待伺服端的回应)

## 为什么有了 HTTP 为什么还要 HTTPS？

https 是安全版的 http，因为 http 协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS 就 是为了解决 HTTP 的不安全⽽⽣的。

## HTTPS 是如何保证安全的？

过程⽐较复杂: `对称加密`、`非对称加密`、`中间人`、`CA证书`、`数字签名`

### 对称加密

即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。

### ⾮对称加密

1. 私钥 + 公钥= 密钥对
2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密
3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅
4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密

⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。

解决⽅案：

那么结合两种加密⽅式，将`对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去`，`接收⽅使⽤私钥进⾏解密 得到对称加密的密钥`，然后双⽅可以使⽤对称加密来进⾏沟通。

### 中间⼈

此时⼜带来⼀个问题，`中间⼈`问题：

如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。(`偷换`)

### CA 证书

所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。

证书中包括：`签发者`、`证书⽤途`、`使⽤者公钥`、`使⽤者私钥`、`使⽤者的 HASH 算法`、`证书到期时间`等

类似一个驾驶证：`签发机构`、`驾驶车辆型号`、`使用者信息`、`证件有效期`

### 证书篡改

但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，`数字签名`。

### 数字签名

数字签名: 就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 这个时候就能最⼤程度保证通信的安全了。

## HTTP2 特点？

- `二进制分帧`
- `头部压缩`
- `服务端推送`
- `多路复用`

:::details 点击查看更多

**⼆进制分帧**

- `帧`：HTTP/2 数据通信的最⼩单位
- `消息`：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。
- `流`：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID HTTP/2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，`⼆进制协议解析起来更⾼效`。

**头部压缩**

HTTP/1.x 会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。 HTTP/2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 ⾸部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 你可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量

**服务器推送**

服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。

场景:

例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端。

**多路复⽤**

HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 `6-8` 个的 TCP 链接请求限制。
HTTP2 中： `同域名下所有通信都在单个连接上完成`。 `单个连接可以承载任意数量的双向数据流`。 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可以重新组装

<img src="http://t-blog-images.aijs.top/img/20220716210046.png" />
:::

## HTTP3 特点？

- `队头阻塞`： 有序字节流引出的`队头阻塞`（Head-of-line blocking），使得 HTTP2 的多路复用能力大打折扣；
- `握手延迟`：`TCP 与 TLS 叠加了握手时延`，建链时长还有 1 倍的下降空间；
- `移动成本高`：基于 TCP 四元组确定一个连接，这种诞生于有线网络的设计，`并不适合移动状态下的无线网络`，这意味着 IP 地址的频繁变动会导致 TCP 连接、TLS 会话反复握手，成本高昂。

## HTTP3 协议解决了这些问题：

- `队头阻塞`：HTTP3 基于 UDP 协议重新定义了连接，在 QUIC 层实现了无序、并发字节流的传输，解决了`队头阻塞问题`（包括基于 QPACK 解决了动态表的队头阻塞）；
- `握手延迟`：HTTP3 重新定义了 TLS 协议加密 QUIC 头部的方式，`既提高了网络攻击成本，又降低了建立连接的速度`（仅需 1 个 RTT 就可以同时完成建链与密钥协商）；
- `移动成本高`： HTTP3 将 Packet、QUIC Frame、HTTP3 Frame 分离，实现了连接迁移功能，`降低了 5G 环境下高速移动设备的连接维护成本`。

## HTTP 的缓存的过程

通常情况下的步骤是:

1. 客户端向服务器发出请求，请求资源
2. 服务器返回资源，并通过响应头决定缓存策略
3. 客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来
4. 在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存

## 强缓存/协商缓存

### 强缓存

强缓存离不开两个响应头 `Expires` 与 `Cache-Control`

**Expires：**

Expires 是 http1.0 提出的⼀个表示资源过期时间的 header，`它描述的是⼀个绝对时间`，由服务器返回， Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

Expires:`Wed, 11 May 2018 07:20:00 GMT` GMT 时间戳

**Cache-Control:**

Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires ,`表示的是相对时间`

Cache-Control: `max-age=315360000`

⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有：

Cache-Control: `public `可以被所有⽤户缓存，`允许终端和 CDN 等中间代理服务器`
Cache-Control: `private` 只能被终端浏览器缓存，`不允许中继缓存服务器进⾏缓存`
Cache-Control: `no-cache`,`先缓存本地,要验证`，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤
Cache-Control: `no-store`，`不会产⽣任何缓存`

在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。

服务器判断缓存是否是新鲜的⽅法就是依靠 HTTP 的另外两组信息

## Last-Modified/If-Modified-Since

客户端⾸次请求资源时，服务器会把资源的最新修改时间

`Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT` 通过响应部⾸发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头

`If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT` 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，

如果服务器的资源更新，那么返回最新的资源，此时状态码 200，
当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回 304 状态码， 表示客户端直接⽤缓存即可。

## ETag/If-None-Match

ETag 的流程跟 Last-Modified 是类似的，区别就在于 ETag 是`根据资源内容进⾏ hash，⽣成⼀个信息摘要`，只要资源内容有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，`⽐ Last-Modified 的精确度要更⾼`。 响应头

<img src="http://t-blog-images.aijs.top/img/20220716205210.png" />

整体的缓存流程图如下：

<img src="http://t-blog-images.aijs.top/img/20220716205325.png" style="max-width:400px"/>

## 参考链接

<a href="https://zhuanlan.zhihu.com/p/431672713" target="_blank" >深入剖析 HTTP3 协议</a>
